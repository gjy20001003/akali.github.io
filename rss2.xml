<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>阿卡丽的黑心商店</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>上古时代的宝贝开卖了！</description>
    <pubDate>Sun, 14 Aug 2022 07:40:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>矩阵</title>
      <link>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/</link>
      <guid>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/</guid>
      <pubDate>Sun, 14 Aug 2022 07:37:01 GMT</pubDate>
      
      <description>&lt;p&gt;矩阵的存储代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>矩阵的存储代码实现</p><span id="more"></span><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    &#x2F;&#x2F;ElemType型一维数组</p><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194725210.png"></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    &#x2F;&#x2F;2行4列的二维数组</p><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194843476.png"></p><p>起始地址：LOC</p><p>行优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194958977.png"></p><p>列优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195101464.png"></p><p>二维数组也具有随机存储的性质</p><h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195510230.png"></p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195836998.png" style="zoom:67%;"><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200202029.png"></p><h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200953049.png"></p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201426822.png" style="zoom:80%;"><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201607063.png" style="zoom:50%;"><p> <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201638617.png" style="zoom: 80%;"><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201828331-16604628178811.png" style="zoom: 67%;"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%9F%A9%E9%98%B5/">矩阵</category>
      
      
      <comments>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>栈和队列的应用</title>
      <link>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <guid>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:32:15 GMT</pubDate>
      
      <description>&lt;p&gt;栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等</p><span id="more"></span><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180407947-16604625560341.png" style="zoom:67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180507316.png" style="zoom:67%;"></p><p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p><p>代码实现</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603182409614.png"></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603183310686.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603184904342.png"></p><p>先出栈的是右操作数，后出栈的是左操作数 </p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603191739417.png"></p><h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192451544.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192500473.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192716850.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603193038318.png"></p><p>递归调用时，函数调用栈可称为递归工作栈</p><p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p><h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p><h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p><p>eg1：</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194341970.png"></p><p>轮流获得cpu的服务</p><p>eg2：</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194439959.png"></p><p>可缓解主机域打印机速度不匹配的问题</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      <category domain="http://example.com/tags/%E9%98%9F%E5%88%97/">队列</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>队列</title>
      <link>http://example.com/2022/08/14/%E9%98%9F%E5%88%97/</link>
      <guid>http://example.com/2022/08/14/%E9%98%9F%E5%88%97/</guid>
      <pubDate>Sun, 14 Aug 2022 07:25:53 GMT</pubDate>
      
      <description>&lt;p&gt;队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义</p><span id="more"></span><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p><p>入队：插入     eg：打饭，高速过闸口</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603163038483.png"></p><p>插入的一段为队尾，删除的一端为队头</p><p>队列的特点：先进先出（First In First Out)(FIFO)</p><p>栈的特点：后进先出（LIFO）</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603163231846.png"></p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断队列已满-x2F-已空-x2F-元素个数"><a href="#判断队列已满-x2F-已空-x2F-元素个数" class="headerlink" title="判断队列已满&#x2F;已空&#x2F;元素个数"></a>判断队列已满&#x2F;已空&#x2F;元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p><p>方案一：</p><p>已满：(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front</p><p>已空：Q.rear &#x3D;&#x3D; Q.front</p><p>方案二：</p><p>增加一个变量 int size  插入成功 size++ 删除成功size – 初始化  size&#x3D;0</p><p>队满条件：size&#x3D;&#x3D;MaxSize    队空条件：size &#x3D;&#x3D;0</p><p>方案三：</p><p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag&#x3D;0）</p><p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p><p>队满条件：front&#x3D;&#x3D;rear&amp;&amp;tag&#x3D;1 </p><p>队空条件：front&#x3D;&#x3D;rear&amp;&amp;tag&#x3D;0</p><h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603170120078.png"></p><p>初始化的时候设置rear&#x3D;MaxSize-1 front&#x3D;0</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603170229143.png" style="zoom: 67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603170342160-16604622170741.png" style="zoom: 67%;"></p><p>判空：方案一：牺牲一个存储单元</p><pre><code>       方案二：设置变量tag或size</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603171845086.png" style="zoom: 67%;"><h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603172140271.png" style="zoom:80%;"><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603174425521.png" style="zoom: 67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603174505573.png" style="zoom:67%;">]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E9%98%9F%E5%88%97/">队列</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%98%9F%E5%88%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>栈</title>
      <link>http://example.com/2022/08/14/%E6%A0%88/</link>
      <guid>http://example.com/2022/08/14/%E6%A0%88/</guid>
      <pubDate>Sun, 14 Aug 2022 07:21:44 GMT</pubDate>
      
      <description>&lt;p&gt;s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现</p><span id="more"></span><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p><img src="/2022/08/14/%E6%A0%88/image-20220602162636874.png" style="zoom:50%;"><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/14/%E6%A0%88/image-20220602162853052.png"></p><p>逻辑结构：与普通线性表相同</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/14/%E6%A0%88/image-20220602163140637.png"></p><p>进栈和出栈</p><img src="/2022/08/14/%E6%A0%88/image-20220602163335955.png" style="zoom:80%;"><h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p><h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>top &#x3D; 0时，栈满时top&#x3D;maxsize&#x3D;10</p><p>top &#x3D; -1时，栈满是top&#x3D;9</p><p>二者的入栈出栈操作正好是翻过来</p><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure><img src="/2022/08/14/%E6%A0%88/image-20220603162012226.png" style="zoom: 50%;"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/14/%E6%A0%88/image-20220603161547608.png"></p><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p><h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/14/%E6%A0%88/image-20220603162308266.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      
      <comments>http://example.com/2022/08/14/%E6%A0%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>顺序表和链表的比较</title>
      <link>http://example.com/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <guid>http://example.com/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <pubDate>Sun, 14 Aug 2022 07:18:12 GMT</pubDate>
      
      <description>&lt;p&gt;对前几篇的总结，比较线性表中顺序表和链表的异同&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>对前几篇的总结，比较线性表中顺序表和链表的异同</p><span id="more"></span><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p><pre><code>          缺点：大片连续空间分配不方便，改变容量不方便</code></pre><p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p><pre><code>           缺点：不可随机存取，存储密度低</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p><h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p><p>链表：只需分配一个头结点（或者头指针）</p><h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length&#x3D;0，静态数组：系统自动回收空间。动态数组：需要手动free</p><p>链表：一次删除各个结点（free）</p><p><img src="/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519211257486.png"></p><h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p><p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p><p>链表的效率比顺序表高得多</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p><pre><code>          按位查找：O(n)，若表内元素有序，可在</code></pre><p>$$<br>O(log_2n)<br>$$<br>时间内找到</p><p>链表: 按位查找：O(n)</p><pre><code>     按值查找：O(n)</code></pre><p>顺序表效率更好</p><p><img src="/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212208066-16604616041971.png"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加&#x2F;删除元素 ——链表</p><p>表长可以预估，查询（搜索）操作较多  ——顺序表</p><h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212403852.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>静态链表</title>
      <link>http://example.com/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:15:15 GMT</pubDate>
      
      <description>&lt;p&gt;静态链表的定义初始化基本操作的原理和代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>静态链表的定义初始化基本操作的原理和代码实现</p><span id="more"></span><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p><p><img src="/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/image-20220519204020786.png"></p><p>游标为-1表示以及到达表尾</p><p>游标充当指针</p><p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：<br>$$<br>addr+8B*2<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p><p>时间复杂度为O(n)</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p><p>(2)从头结点出发找到位序为i-1的结点</p><p>(3)修改新结点的next</p><p>(4)修改i-号结点的next</p><p>如何判断为空？————可以让next设置为特殊值</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p><p>(2)修改前驱结点的游标</p><p>(3)被删除的结点next设为-2</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p><p>逻辑上相邻的元素可以在物理上不相邻</p><p>优点：增删操作不需要大量移动元素</p><p>缺点：不能随机存取，固定容量不可变</p><p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>循环链表</title>
      <link>http://example.com/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:12:40 GMT</pubDate>
      
      <description>&lt;p&gt;循环单链表和循环双链表的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>循环单链表和循环双链表的代码实现</p><span id="more"></span><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519201322333.png"></p><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环单链表可以从任意一个点出发找到任何一个结点</p><p>应用场景：在项目中需要经常对表头和表尾进行操作</p><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202518705.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202611055.png"></p><p>示意图</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202626494.png"></p><p>判空</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202646358.png"></p><p>寻找表尾</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202653076.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双链表</title>
      <link>http://example.com/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 03:30:56 GMT</pubDate>
      
      <description>&lt;p&gt;双链表的初始化、基本操作和遍历&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>双链表的初始化、基本操作和遍历</p><span id="more"></span><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = null;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174125025.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>后插操作</p><p><img src="/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174230546.png"></p><p><img src="/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174327671.png"></p><p>前插操作：通过双链表的特性可以找到插入位置的前一个结点，再对该结点进行后插操作</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeketeNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==null)          <span class="comment">//p没有后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=null)</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="销毁双链表"><a href="#销毁双链表" class="headerlink" title="销毁双链表"></a>销毁双链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != null)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);   <span class="comment">//释放头结点</span></span><br><span class="line">    L=null;    <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg按位查找按值查找打印等</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != null)&#123;</span><br><span class="line">p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:O(n)</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://example.com/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/</link>
      <guid>http://example.com/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 03:24:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;网络媒体信息获取一般流程&quot;&gt;&lt;a href=&quot;#网络媒体信息获取一般流程&quot; class=&quot;headerlink&quot; title=&quot;网络媒体信息获取一般流程&quot;&gt;&lt;/a&gt;网络媒体信息获取一般流程&lt;/h1&gt;&lt;h2 id=&quot;理想的网络媒体信息获取流程&quot;&gt;&lt;a href=&quot;#</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="网络媒体信息获取一般流程"><a href="#网络媒体信息获取一般流程" class="headerlink" title="网络媒体信息获取一般流程"></a>网络媒体信息获取一般流程</h1><h2 id="理想的网络媒体信息获取流程"><a href="#理想的网络媒体信息获取流程" class="headerlink" title="理想的网络媒体信息获取流程"></a>理想的网络媒体信息获取流程</h2><p>——初始URL集合<br>——信息获取<br>——信息解析<br>——信息判重</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611180833529.png"></p><h2 id="初始URL集合"><a href="#初始URL集合" class="headerlink" title="初始URL集合"></a>初始URL集合</h2><p>最初由搜索引擎研究人员提出<br>维护相当数量初始URL集合<br>网页内嵌地址的递归操作<br>形象地称为信息“种子”集合</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611180901579.png"></p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611181045951.png" alt="image-20220611181045951"></p><h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><p>待获取内容协议解析<br>向信息发布网站请求所需内容<br>接收来自网站的响应信息<br>传递给后续的信息解析模块</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611181119832.png"></p><h2 id="信息内容解析"><a href="#信息内容解析" class="headerlink" title="信息内容解析"></a>信息内容解析</h2><p>提取发布信息的主体内容<br>维护与网络内容的关键字段<br>内容转交至信息判重模块<br>关键字段存入信息库</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611181213532.png"></p><h2 id="信息判重"><a href="#信息判重" class="headerlink" title="信息判重"></a>信息判重</h2><p>判定是否已获取内嵌URL信息内容<br>若是，注明信息失效时间及最近修改时间的URL<br>否则重启完整的信息采集操作<br>向对应的网络内容发布媒体发起信息查新获取操作</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611181245716.png"></p><h1 id="中文分词技术特点"><a href="#中文分词技术特点" class="headerlink" title="中文分词技术特点"></a>中文分词技术特点</h1><p>中文是以字为基本书写单位，单个字往往不足以表达一个意思，通常认为词是表达语义的最小元素。因此须对中文字符串进行合理的切分。<br>特征粒度为词粒度远远好于字粒度，其大部分分类算法不考虑词序信息，基于字粒度的损失了过多的n-gram信息。</p><h2 id="基于词典方法"><a href="#基于词典方法" class="headerlink" title="基于词典方法"></a>基于词典方法</h2><p>优点是：分词过程是跟词典作比较，不需要大量的语料库、规则库，其算法简单、复杂性小、对算法作一定的预处理后分词速度较快；<br>缺点是：不能消除歧义、识别未登录词，对词典的依赖性比较大，若词典足够大，其效果会更加明显。</p><h2 id="基于统计方法"><a href="#基于统计方法" class="headerlink" title="基于统计方法"></a>基于统计方法</h2><p>优点是：由于是基于统计规律的，对未登录词的识别表现出了一定的优越性，不需要预设词典；<br>缺点是：需要一个足够大的语料库来统计训练，其正确性很大程度上依赖训练语料库的质量好坏，算法较为复杂，计算量大，周期长，但是都较为常见，处理速度一般。</p><h2 id="基于理解方法"><a href="#基于理解方法" class="headerlink" title="基于理解方法"></a>基于理解方法</h2><p>优点是：由于能理解字符串含义，对未登录词具有很强的识别能力，能很好的解决歧义问题，不需要词典及大量语料库训练；<br>缺点是：需要一个准确、完备的规则库，依赖性较强，效果好坏往往取决于规则库的完整性。算法比较复杂、实现技术难度较大，处理速度比较慢。</p><h2 id="语义特征提取"><a href="#语义特征提取" class="headerlink" title="语义特征提取"></a>语义特征提取</h2><h3 id="语义特征需具备如下特征"><a href="#语义特征需具备如下特征" class="headerlink" title="语义特征需具备如下特征"></a>语义特征需具备如下特征</h3><p>特征项要能确实标识文本内容</p><p>能够将目标文本与其他文本相区分</p><p>特征项的个数不能太多</p><p>特征项分离要比较容易实现</p><p><strong>根据语义级别由低到高来分，文本语义特征可分为：亚词级别、词级别、多词级别、语义级别和语用级别。其中，应用最为广泛的是词级别。</strong></p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611181558637.png"></p><h2 id="词级别语义特征"><a href="#词级别语义特征" class="headerlink" title="词级别语义特征"></a>词级别语义特征</h2><p>词特征可进行计算的因素有很多，最常用的有：词频词性。还有文档，词语长度，词语直径，首次出现位置</p><p><strong>词级别(WordLevel)以词作为基本语义特征。以单词作为基本语义特征在文本分类、信息检索系统中工作良好，是最常见的基本语义特征。</strong></p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611181758848.png"></p><h2 id="亚词级别语义特征"><a href="#亚词级别语义特征" class="headerlink" title="亚词级别语义特征"></a>亚词级别语义特征</h2><p>亚词级别(Sub-Word Level)也称为字素级别(Graphemic Level)。在英文中比词级别更低的文字组成单位是字母，在汉语中则是单字。</p><h2 id="多词级别语义特征"><a href="#多词级别语义特征" class="headerlink" title="多词级别语义特征"></a>多词级别语义特征</h2><p>多词级别 (Multi-Word Leve1) 指用多个词作为文本的特征项，多词可以比词级别表示更多的语义信息；<br>经常从统计角度根据词之间较高的同现频率(Co-OccurFrequency) 来选取特征项</p><h2 id="n元模型"><a href="#n元模型" class="headerlink" title="n元模型"></a>n元模型</h2><p>n元模型将文本表示为重叠的n个连续字母(对应汉语情况为单字)的序列作为特征项；<br>采用 n元模型时，需要考虑数值n的选择问题。</p><h2 id="语言模型：词袋模型"><a href="#语言模型：词袋模型" class="headerlink" title="语言模型：词袋模型"></a>语言模型：词袋模型</h2><p>将单词和句子表示为数字向量的形式，其中向量元素为句子中此单词在词袋表出现的次数。然后将数字向量输入分类器(例如Naive Bayes)，进而对输出进行预测。这种表示方式不考虑文法以及词的顺序。</p><p>例如以下两个句子：<br>John likes to watch movies. Mary likes movies too.<br>John also likes to watch football games.<br>基于以上两个句子，可以建构词袋表：[ “John”, “likes”, “to”, “watch”, “movies”, “also”, “football”, “games”, “Mary”, “too” ]<br>由于词袋表的长度为10，所以每个句子的数字向量表示长度也为10。下面是每个句子的向量表示形式：<br>[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]<br>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]<br>优缺点都很明显<br>优点是基于频率统计方法，易于理解。缺点是它的假设(单词之间完全独立)过于强大，无法建立准确的模型。</p><h2 id="词的描述：one-hot表示"><a href="#词的描述：one-hot表示" class="headerlink" title="词的描述：one-hot表示"></a>词的描述：one-hot表示</h2><p>基于词袋模型，可以用向量描述一个词，其向量维度大小为整个词汇表的大小，对于每个具体的词汇表中的词，将对应的位置置为1。</p><p>例如，以下5词组成的词汇表，Queen的序号为2， 其词向量为(0,1,0,0,0)，而Woman的词向量为(0,0,0,1,0)。<br>上述编码，称为1-of-N 表示或者one hot representation(单热表示).<br>当然，单热编码的词的维度元素非0即1，且词之间彼此相互独立。<br>可能导致词向量维度巨大，表达效率不高<br>无法反映文本的有序性</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611182222965.png"></p><h2 id="语言模型：N-Gram模型"><a href="#语言模型：N-Gram模型" class="headerlink" title="语言模型：N-Gram模型"></a>语言模型：N-Gram模型</h2><p>马尔可夫链规定：系统下一时刻的状态仅由当前状态决定，不依赖于以往的任何状态。即第t + 1个单词的发生概率表示为：<br>                                    <img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611182315117.png"><br>因此，一个句子的概率可以表示为：<br>                                    <img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611182346849.png"><br>同样地，马尔可夫假设可以推广到：系统下一时刻的状态仅由当前0个、1个、2个…n个状态决定。这就是N-gram model的N的意思：对下一时刻的状态设置当前状态的个数。下面分别给出了unigram（一元模型）和bigram（二元模型)的第t + 1个单词的发生概率：<br>                                    <img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/image-20220611182419447.png"><br>可以发现，N-Gram 模型在词袋的基础上，通过采用马尔科夫链的思想，减少了概率计算的复杂度，同时考虑了单词间的相关性。</p><h3 id="例：二元语言模型判断句子是否合理"><a href="#例：二元语言模型判断句子是否合理" class="headerlink" title="例：二元语言模型判断句子是否合理"></a>例：二元语言模型判断句子是否合理</h3><p>假设现在有一个语料库，我们统计了下面的一些词出现的数量</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611182528334.png" alt="image-20220611182528334"></p><p>面的这些概率值作为已知条件：</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611182602442.png" alt="image-20220611182602442"></p><p>下面这个表给出的是基于Bigram模型进行计数之结果</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611182907750.png" alt="image-20220611182907750"></p><p>例如，其中第一行，第二列 表示给定前一个词是 “i” 时，当前词为“want”的情况一共出现了827次。据此，我们便可以算得相应的频率分布表如下</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611182919951.png" alt="image-20220611182919951"></p><p>以表中的p(eat|i)&#x3D;0.0036这个概率值讲解，从上页的表中得出“i”一共出现了2533次，而其后出现eat的次数一共有9次，<br>p(eat|i)&#x3D;p(i, eat)&#x2F;p(i) &#x3D; count(i,eat)&#x2F;count(i) &#x3D; 9&#x2F;2533 &#x3D; 0.0036</p><p>通过基于这个语料库来判断s1&#x3D;“<s> i want english food</s>” 与s2 &#x3D; “<s> want i english food</s>“哪个句子更合理.</p><p>首先来判断p(s1)<br>P(s1)&#x3D;P(i|<s>)P(want|i)P(english|want)P(food|english)P(</s>|food)<br>        &#x3D;0.25×0.33×0.0011×0.5×0.68&#x3D;0.000031</p><p>再来求p(s2)<br>P(s2)&#x3D;P(want|<s>)P(i|want)P(english|want)P(food|english)P(</s>|food)<br>        &#x3D;0.25<em>0.0022</em>0.0011<em>0.5</em>0.68 &#x3D; 0.00000002057</p><p>显然 0.00000002057&lt;0.000031,即 s1&#x3D; “i want english food“更像人话。</p><h3 id="N-gram模型的一个常见应用：联想词"><a href="#N-gram模型的一个常见应用：联想词" class="headerlink" title="N-gram模型的一个常见应用：联想词"></a>N-gram模型的一个常见应用：联想词</h3><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611183043714.png" alt="image-20220611183043714" style="zoom: 50%;"><p>实际上是根据语言模型得出。假如使用的是二元语言模型预测下一个单词：<br>排序的过程就是依据概率：<br>    p(”不一样“|”我们”)&gt;p(”的爱“|”我们”)&gt;p(”相爱吧“|”我们”)&gt;…….&gt;p(“这一家”|”我们“)</p><p>这些概率值的求法和上面提到的完全一样，数据的来源可以是用户搜索的log</p><h2 id="网络信息内容过滤"><a href="#网络信息内容过滤" class="headerlink" title="网络信息内容过滤"></a>网络信息内容过滤</h2><p>根据用户的信息需求，运用一定的标准和工具，从大量的动态网络信息流中选取相关的信息或剔除不相关信息的过程。<br>相比于信息检索技术，网络信息过滤技术是一种更系统化的方法，用来从动态的信息流中抽取出符合个性化需求的信息<br>相比于传统的信息检索模式，信息过滤技术具有较高的可扩展性，能适应大规模用户群和海量信息<br>可以为用户提供及时、个性化的信息服务，具有了一定的智能和较高的自动化程度</p><h2 id="网络信息内容过滤的意义"><a href="#网络信息内容过滤的意义" class="headerlink" title="网络信息内容过滤的意义"></a>网络信息内容过滤的意义</h2><p>改善Internet信息查询技术的需要<br>个性化服务的基础<br>维护我国信息安全的迫切需要<br>信息中介（信息服务供应商）开展网络增值服务的手段</p><h2 id="变体词的出现及识别意义"><a href="#变体词的出现及识别意义" class="headerlink" title="变体词的出现及识别意义"></a>变体词的出现及识别意义</h2><p>变体词是网络语言作为一种不规范语言的显著特色, 人们往往出于避免审查、表达情感、讽刺、娱乐等需求将相对严肃、规范、敏感的词用相对不规范、不敏感的词来代替, 用来代替原来词的新词，从而形成变体词(Morph) 。<br>变体词和其对应的目标实体词分别在非规范文本和规范文本中共存, 甚至变体词会渗透到规范文本中。<br>——变体词使行文生动活泼, 相关事件、消息也传播得更加广泛。<br>——变体词通常是某种隐喻, 已不再是其表面字词的意义了, 从而使网络上文体与正式文本    (如新闻等)具有巨大的差异。<br>如何识别出这些变体词及其所对应的目标实体词，对于下游的自然语言处理技术具有重要的意义。</p><h2 id="变体词的生成规律"><a href="#变体词的生成规律" class="headerlink" title="变体词的生成规律"></a>变体词的生成规律</h2><p>变体词多采用同音异形异义词<br>——同音异形异义词在中文中十分普遍<br>——中文字数虽然很多, 但是语音是有限的。<br>       · 据统计中文中 80%的单语音字是有歧义的, 而且其中有一半对应 5 个以上的字。<br>利用中文的特点生成变体词。<br>——利用中文文字的拆分组合、翻译、昵称等手段来创建变体词。<br>利用深层语义信息、背景知识、特定事件等综合生成变体词</p><h2 id="变体词识别与规范化方法"><a href="#变体词识别与规范化方法" class="headerlink" title="变体词识别与规范化方法"></a>变体词识别与规范化方法</h2><p>基于规则的识别和规范化方法<br>——相关研究包括网络不良文本的过滤技术。<br>       · 传统的精确匹配、分类器等方法会由于变体词的出现，严重影响到过滤准确度。<br>——对变体词的处理,<br>       · 分析变体词的变体规则, 提取变体词的 bigram、词干等特征，实现对变体词的识别<br>       · 根据汉语的语音特点，建立语音映射模型, 基于语音的相似性度量实现对变体词的识别。</p><p>基于统计和规则的识别和规范化<br>——提取统计特征和基于规则的特征, 建立变体词与目标实体词之间的映射关系<br>——通过分类方法，基于上下文相似性和字面相似性实现对变体词的规范化</p><p>基于语义表示的识别和规范化方法<br>——给定一个变体词, 如果另一个词与之上下文相似, 则可以初步推断这个词很可能 就是变体词的目标实体词。<br>        · 根据一定时间窗口内变体词和目标实体词是相关;<br>        · 根据社交媒体的动态特性提取变体词和目标实体词的时空分布;<br>        · 对多个数据源数据进行对比分析;对用户的行为建模,用社交行为的相关性来辅助语义相似性测量。 </p><p>与其他应用的结合<br>——变体词的识别与规范化与下游的自然语言 处理任务实际上是相互影响相互作用的, 例如分词。可以将变体词任务与下游的任务结合起来, 形成一个闭环相互反馈相互提高。</p><h2 id="话题检测与跟踪-Topic-Detection-and-Tracking-（TDT）"><a href="#话题检测与跟踪-Topic-Detection-and-Tracking-（TDT）" class="headerlink" title="话题检测与跟踪 Topic Detection and Tracking （TDT）"></a>话题检测与跟踪 Topic Detection and Tracking （TDT）</h2><p>美国国际高级研究计划局（DARPA）于1996年发起倡议，主要用于没有人工干预的情况下自动判断新闻数据流的主题。实现在新闻报道流中发现和跟踪新事件，完成新闻报道边界的自动识别、锁定和发现突发性新闻话题、跟踪话题发生发展过程等相关任务。<br>现在也广泛应用于社交媒体领域</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611183609784.png" alt="image-20220611183609784"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611183627454.png" alt="image-20220611183627454"></p><h2 id="TDT的基本任务"><a href="#TDT的基本任务" class="headerlink" title="TDT的基本任务"></a>TDT的基本任务</h2><p>报道切分 SST，Story Segmentation<br>话题跟踪 TT, Topic Tracking<br>话题检测 TD, Topic Detection Task<br>首次报道检测 FST,First-Story Detection Task<br>关联检测 LDT, Link Detection Task</p><p><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611183656535.png" alt="image-20220611183656535"></p><h2 id="社交网络结构分析与建模"><a href="#社交网络结构分析与建模" class="headerlink" title="社交网络结构分析与建模"></a>社交网络结构分析与建模</h2><p>社交网络模型许多概念来自于图论，本质上可视为一个由节点（人）和边（社交关系）组成的图。<br>——度（Degree）：节点的度定义为与该节点相连的边的数目。在有向图中，所有指向某节点的边的数量叫作该节点的入度，所有从该节点出发指向别的节点的边的数量叫作该节点的出度。网络平均度反应了网络的疏密程度，而通过度分布则可以刻画不同节点的重要性。</p><p>——网络密度（Density）：网络密度可以用于刻画节点间相互连边的密集程度，定义为网络中实际存在边数与可容纳边数上限的比值，常用来测量社交网络中社交关系的密集程度及演化趋势。</p><p>——聚类系数（Clustering Coefficient）：用于描述网络中与同一节点相连的节点间也互为相邻节点的程度。其用于刻画社交网络中一个人朋友们之间也互相是朋友的概率，反应了社交网络中的聚集性。</p><p>——介数（Betweeness）：为图中某节点承载整个图所有最短路径的数量，通常用来评价节点的重要程度，比如在连接不同社群之间的中介节点的介数相对于其他节点来说会非常大，也体现了其在社交网络信息传递中的重要程度。</p><h2 id="网络特性"><a href="#网络特性" class="headerlink" title="网络特性"></a>网络特性</h2><p>· 小世界现象 small world<br>——指地理位置相距遥远的人可能具有较短的社会关系间隔。<br>——1967年，哈佛大学教授Milgram的信件投递实验：六度分离理论<br>——1998年，Watts 和Strogatz 的《自然》文章《Collective Dynamics of “Small-World” Networks》。<br>——2011年 的Facebook 数据分析表明， Facebook 约7.2亿用户中任意两个用户间的平均路径长度仅为4.74，而这一指标在推特中为4.67。<br>——互联网的节点是各个路由器，连边则是连接各个路由器的光纤。在 1995<del>1999 年对于互联网网站及路由器层次都进行了计算，发现互联网的平均路径长度是 L&#x3D; 4.0<br>——语言网络也是小世界网络。每一个单词是一个节点，两个单词相连接出现在一个句子中即为有连边。据计算，两个单词之间的平均距离是 d &#x3D; 2</del>3 (Romaine, 1992)</p><p>· 无标度（scale-free）特性<br>——大多数真实的大规模社交网络都存在着大多数节点有少量边，少数节点有大量边的特点，其网络缺乏一个统一的衡量尺度而呈现出异质性。<br>——这种节点度分布不存在有限衡量分布范围的性质称为无标度。<br>——无标度网络表现出来的度分布特征为幂律分布，构成此类网络的无标度特性。<br><img src="/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220611183851563.png" alt="image-20220611183851563"><br>· 无标度网络模型也称为BA模型</p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>· WS 模型：WS 模型即小世界模型，通过小世界模型生成的小世界网络是从规则网络向随机网络过渡的中间形态。<br>· BA 模型：BA模型考虑到现实网络中节点的幂律分布特性，生成无标度网络。<br>· 其他模型：森林火灾模型，Kronecker 模型，生产模型。</p><h2 id="网络舆情分析概述"><a href="#网络舆情分析概述" class="headerlink" title="网络舆情分析概述"></a>网络舆情分析概述</h2><h3 id="网络舆情"><a href="#网络舆情" class="headerlink" title="网络舆情"></a>网络舆情</h3><p>舆情指在一定的社会空间内，围绕中介性社会事项的发生、发展和变化，作为主体的民众对作为客体的国家管理者产生和持有的社会政治态度。如果把中间的一些定语省略掉，<strong>舆情就是民众的社会政治态度。</strong></p><h2 id="网络舆情分析的特点"><a href="#网络舆情分析的特点" class="headerlink" title="网络舆情分析的特点"></a>网络舆情分析的特点</h2><p>直接性：通过网络直接发表意见，传播迅速<br>随意性和多元化：网民可匿名发表观点，健康观点和灰色言论并存<br>突发性：网络快速传播的特性使关注焦点迅速成长为舆论热点<br>隐蔽性：虚拟网络空间中网民可以隐身发言<br>偏差性：网络舆情不等同于全民立场</p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/08/14/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单链表的基本操作</title>
      <link>http://example.com/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Sun, 14 Aug 2022 03:15:03 GMT</pubDate>
      
      <description>&lt;p&gt;单链表的插入删除和查找操作的原理解析和代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>单链表的插入删除和查找操作的原理解析和代码实现</p><span id="more"></span><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p>带头结点</p><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519145908546.png"></p><p>if i &#x3D; 6 : p指向NULL，则第i-1节点不存在，直接返回false</p><p>时间复杂度：O(n)</p><p>不带头节点</p><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519150604589.png"></p><p>不带头结点需要一段单独的代码来应对i&#x3D;1的情况</p><h4 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,* LinkList</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InserNextNode</span> <span class="params">(LNode *p ,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)               <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;              <span class="comment">//结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode *p;</span><br><span class="line">   <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p! = <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p>两种方法：（1)传入头节点，依次遍历（2）采用后插方式，将节点p的值赋给新申请的节点，将插入的值赋给节点p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insertpriornode</span> <span class="params">(LNode *p, ElemTyoe e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;            <span class="comment">//新结点s连到p结点后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;      <span class="comment">//将p中元素赋值给s</span></span><br><span class="line">    p-&gt;data=e;            <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519153009590.png"></p><p>时间复杂度：O(1)</p><h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519154105544.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">listdelete</span><span class="params">(linklist &amp;L,<span class="type">int</span> i,elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q=p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好时间复杂度：O(1)</p><p>最坏&#x2F;平均时间复杂度：O(n)</p><h4 id="指定节点的删除"><a href="#指定节点的删除" class="headerlink" title="指定节点的删除"></a>指定节点的删除</h4><p>下面例子为带头结点的单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">deletenode</span> <span class="params">(lnode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p--<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>如果p是最后一个节点，只能依次寻找p的前驱，时间复杂度为O(n)</p><h3 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h3><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519162949205.png"></p><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均时间复杂度：O(n)</p><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="type">int</span> len =<span class="number">0</span>;           <span class="comment">//统计表长</span></span><br><span class="line">LNode *p = L;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/">顺序表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
