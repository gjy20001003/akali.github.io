<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>阿卡丽的黑心商店</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>上古时代的宝贝开卖了！</description>
    <pubDate>Sun, 14 Aug 2022 08:15:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>吐槽</title>
      <link>http://example.com/2022/08/14/%E5%90%90%E6%A7%BD/</link>
      <guid>http://example.com/2022/08/14/%E5%90%90%E6%A7%BD/</guid>
      <pubDate>Sun, 14 Aug 2022 08:10:47 GMT</pubDate>
      
      <description>&lt;p&gt;日常吐槽&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>日常吐槽</p><span id="more"></span><p>在往博客上写东西的时候，接到家里的电话，接了之后蹦了一句你是不是在玩游戏，我直接不知道怎么接了，难搞</p><p><img src="/2022/08/14/%E5%90%90%E6%A7%BD/image-20220814161527134.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E9%9A%8F%E7%AC%94%EF%BC%8C%E5%90%90%E6%A7%BD/">随笔，吐槽</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%90%90%E6%A7%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>矩阵</title>
      <link>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/</link>
      <guid>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/</guid>
      <pubDate>Sun, 14 Aug 2022 07:37:01 GMT</pubDate>
      
      <description>&lt;p&gt;矩阵的存储代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>矩阵的存储代码实现</p><span id="more"></span><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    &#x2F;&#x2F;ElemType型一维数组</p><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194725210.png"></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    &#x2F;&#x2F;2行4列的二维数组</p><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194843476.png"></p><p>起始地址：LOC</p><p>行优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194958977.png"></p><p>列优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195101464.png"></p><p>二维数组也具有随机存储的性质</p><h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195510230.png"></p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195836998.png" style="zoom:67%;"><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200202029.png"></p><h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200953049.png"></p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201426822.png" style="zoom:80%;"><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201607063.png" style="zoom:50%;"><p> <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201638617.png" style="zoom: 80%;"><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201828331-16604628178811.png" style="zoom: 67%;"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%9F%A9%E9%98%B5/">矩阵</category>
      
      
      <comments>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>栈和队列的应用</title>
      <link>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <guid>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:32:15 GMT</pubDate>
      
      <description>&lt;p&gt;栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等</p><span id="more"></span><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180407947-16604625560341.png" style="zoom:67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180507316.png" style="zoom:67%;"></p><p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p><p>代码实现</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603182409614.png"></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603183310686.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603184904342.png"></p><p>先出栈的是右操作数，后出栈的是左操作数 </p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603191739417.png"></p><h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192451544.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192500473.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192716850.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603193038318.png"></p><p>递归调用时，函数调用栈可称为递归工作栈</p><p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p><h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p><h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p><p>eg1：</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194341970.png"></p><p>轮流获得cpu的服务</p><p>eg2：</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194439959.png"></p><p>可缓解主机域打印机速度不匹配的问题</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      <category domain="http://example.com/tags/%E9%98%9F%E5%88%97/">队列</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>洛阳</title>
      <link>http://example.com/2022/08/13/%E9%95%BF%E5%AE%89/</link>
      <guid>http://example.com/2022/08/13/%E9%95%BF%E5%AE%89/</guid>
      <pubDate>Sat, 13 Aug 2022 15:38:43 GMT</pubDate>
      
      <description>&lt;p&gt;《你要写月，就不能只写月》仿写——历历山河&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>《你要写月，就不能只写月》仿写——历历山河</p><span id="more"></span><p>你要写洛阳，就不能只写洛阳</p><p>要写盛唐，写浮光<br>写这天下之众的攘攘与如霜</p><p>要写玉楼金阙拂衣裳，诗酒华章<br>写纸贵绝唱，写家书两行，<br>写一位陌上看花的冰心少年郎</p><p>写此夜玉笛声回荡，写满是京城牡丹香<br>再写白驹过隙梦黄粱，人世间茫茫</p><p>罢笔之时，欲晚天光<br>惊觉此身感秋凉，锦绣意气仍朗朗<br>当时只道是寻常</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <comments>http://example.com/2022/08/13/%E9%95%BF%E5%AE%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>队列</title>
      <link>http://example.com/2022/08/13/%E9%98%9F%E5%88%97/</link>
      <guid>http://example.com/2022/08/13/%E9%98%9F%E5%88%97/</guid>
      <pubDate>Sat, 13 Aug 2022 07:25:53 GMT</pubDate>
      
      <description>&lt;p&gt;队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义</p><span id="more"></span><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p><p>入队：插入     eg：打饭，高速过闸口</p><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603163038483.png"></p><p>插入的一段为队尾，删除的一端为队头</p><p>队列的特点：先进先出（First In First Out)(FIFO)</p><p>栈的特点：后进先出（LIFO）</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603163231846.png"></p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断队列已满-x2F-已空-x2F-元素个数"><a href="#判断队列已满-x2F-已空-x2F-元素个数" class="headerlink" title="判断队列已满&#x2F;已空&#x2F;元素个数"></a>判断队列已满&#x2F;已空&#x2F;元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p><p>方案一：</p><p>已满：(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front</p><p>已空：Q.rear &#x3D;&#x3D; Q.front</p><p>方案二：</p><p>增加一个变量 int size  插入成功 size++ 删除成功size – 初始化  size&#x3D;0</p><p>队满条件：size&#x3D;&#x3D;MaxSize    队空条件：size &#x3D;&#x3D;0</p><p>方案三：</p><p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag&#x3D;0）</p><p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p><p>队满条件：front&#x3D;&#x3D;rear&amp;&amp;tag&#x3D;1 </p><p>队空条件：front&#x3D;&#x3D;rear&amp;&amp;tag&#x3D;0</p><h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170120078.png"></p><p>初始化的时候设置rear&#x3D;MaxSize-1 front&#x3D;0</p><p><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170229143.png" style="zoom: 67%;"><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603170342160-16604622170741.png" style="zoom: 67%;"></p><p>判空：方案一：牺牲一个存储单元</p><pre><code>       方案二：设置变量tag或size</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603171845086.png" style="zoom: 67%;"><h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603172140271.png" style="zoom:80%;"><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603174425521.png" style="zoom: 67%;"><img src="/2022/08/13/%E9%98%9F%E5%88%97/image-20220603174505573.png" style="zoom:67%;">]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E9%98%9F%E5%88%97/">队列</category>
      
      
      <comments>http://example.com/2022/08/13/%E9%98%9F%E5%88%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>栈</title>
      <link>http://example.com/2022/08/13/%E6%A0%88/</link>
      <guid>http://example.com/2022/08/13/%E6%A0%88/</guid>
      <pubDate>Sat, 13 Aug 2022 07:21:44 GMT</pubDate>
      
      <description>&lt;p&gt;s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现</p><span id="more"></span><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p><img src="/2022/08/13/%E6%A0%88/image-20220602162636874.png" style="zoom:50%;"><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/13/%E6%A0%88/image-20220602162853052.png"></p><p>逻辑结构：与普通线性表相同</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/13/%E6%A0%88/image-20220602163140637.png"></p><p>进栈和出栈</p><img src="/2022/08/13/%E6%A0%88/image-20220602163335955.png" style="zoom:80%;"><h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p><h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>top &#x3D; 0时，栈满时top&#x3D;maxsize&#x3D;10</p><p>top &#x3D; -1时，栈满是top&#x3D;9</p><p>二者的入栈出栈操作正好是翻过来</p><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure><img src="/2022/08/13/%E6%A0%88/image-20220603162012226.png" style="zoom: 50%;"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/13/%E6%A0%88/image-20220603161547608.png"></p><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p><h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/13/%E6%A0%88/image-20220603162308266.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      
      <comments>http://example.com/2022/08/13/%E6%A0%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>8.8-8.12--工作报告</title>
      <link>http://example.com/2022/08/12/8-8-8-12-%E5%B7%A5%E4%BD%9C%E6%8A%A5%E5%91%8A/</link>
      <guid>http://example.com/2022/08/12/8-8-8-12-%E5%B7%A5%E4%BD%9C%E6%8A%A5%E5%91%8A/</guid>
      <pubDate>Fri, 12 Aug 2022 09:06:56 GMT</pubDate>
      
      <description>&lt;p&gt;8.8-8.12 工作总结周报&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>8.8-8.12 工作总结周报</p><span id="more"></span><p>本周主要进行了对cwe漏洞库的翻译工作，学习和认识了漏洞的种类，等级，概述和使用方法。认识到CWE是一个常见漏洞和暴露的清单，详细说明了在各种软件和硬件中发现的漏洞，但是在CWE中并没有提到环节策略来防止攻击者利用他们呢，在ATT&amp;CK为许多而已战术提供了缓解技术。并进行了对上一周obpm漏洞的补充，主要是互联网上的案例如oa.dacpe.com,微企365等使用该系统漏洞存在的证明，以及去了解学习和复现了致远OA任意文件上传漏洞，当时学习到致远OA的问题是在upload.php文件中if else语句中存在如果传入一个参数p就可以跳过登录界面，所以使用burpisute抓包进行传入path等数据(该漏洞还有连带而出的其他文件上的漏洞)，所以在周五的任务中要查看OBPM源代码确定漏洞所在位置和组件名称，我的思路首先就是关于上传方面的文件的查看，看到了一些if else语句可能存在代码漏洞，以及实用的第三方库好像有一些问题，但是因为是根据poc漏洞逆推，如果正向查找并找不到该疑似漏洞文件的路径，就找了很久，后来在和同事的交流中认识到在另外一个文件中提到了这个直接查找并找不到的路径，我和同事的是发现者通过浏览源代码看到了该文件中提到了一个无法直接找到路径的文件，再查看该文件后看到了存在的该文件中存在漏洞，在该文件中获得上传权限后，再在目标文件夹下载该文件完成对该OA系统的攻击，下周会尝试进行复刻这个过程验证自己思路的正确性。</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <comments>http://example.com/2022/08/12/8-8-8-12-%E5%B7%A5%E4%BD%9C%E6%8A%A5%E5%91%8A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>顺序表和链表的比较</title>
      <link>http://example.com/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <guid>http://example.com/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <pubDate>Thu, 11 Aug 2022 07:18:12 GMT</pubDate>
      
      <description>&lt;p&gt;对前几篇的总结，比较线性表中顺序表和链表的异同&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>对前几篇的总结，比较线性表中顺序表和链表的异同</p><span id="more"></span><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p><pre><code>          缺点：大片连续空间分配不方便，改变容量不方便</code></pre><p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p><pre><code>           缺点：不可随机存取，存储密度低</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p><h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p><p>链表：只需分配一个头结点（或者头指针）</p><h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length&#x3D;0，静态数组：系统自动回收空间。动态数组：需要手动free</p><p>链表：一次删除各个结点（free）</p><p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519211257486.png"></p><h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p><p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p><p>链表的效率比顺序表高得多</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p><pre><code>          按位查找：O(n)，若表内元素有序，可在</code></pre><p>$$<br>O(log_2n)<br>$$<br>时间内找到</p><p>链表: 按位查找：O(n)</p><pre><code>     按值查找：O(n)</code></pre><p>顺序表效率更好</p><p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212208066-16604616041971.png"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加&#x2F;删除元素 ——链表</p><p>表长可以预估，查询（搜索）操作较多  ——顺序表</p><h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212403852.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      
      <comments>http://example.com/2022/08/11/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>静态链表</title>
      <link>http://example.com/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Wed, 10 Aug 2022 07:15:15 GMT</pubDate>
      
      <description>&lt;p&gt;静态链表的定义初始化基本操作的原理和代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>静态链表的定义初始化基本操作的原理和代码实现</p><span id="more"></span><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p><p><img src="/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/image-20220519204020786.png"></p><p>游标为-1表示以及到达表尾</p><p>游标充当指针</p><p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：<br>$$<br>addr+8B*2<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p><p>时间复杂度为O(n)</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p><p>(2)从头结点出发找到位序为i-1的结点</p><p>(3)修改新结点的next</p><p>(4)修改i-号结点的next</p><p>如何判断为空？————可以让next设置为特殊值</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p><p>(2)修改前驱结点的游标</p><p>(3)被删除的结点next设为-2</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p><p>逻辑上相邻的元素可以在物理上不相邻</p><p>优点：增删操作不需要大量移动元素</p><p>缺点：不能随机存取，固定容量不可变</p><p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/10/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>循环链表</title>
      <link>http://example.com/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Wed, 10 Aug 2022 07:12:40 GMT</pubDate>
      
      <description>&lt;p&gt;循环单链表和循环双链表的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>循环单链表和循环双链表的代码实现</p><span id="more"></span><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519201322333.png"></p><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环单链表可以从任意一个点出发找到任何一个结点</p><p>应用场景：在项目中需要经常对表头和表尾进行操作</p><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202518705.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202611055.png"></p><p>示意图</p><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202626494.png"></p><p>判空</p><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202646358.png"></p><p>寻找表尾</p><p><img src="/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202653076.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/10/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
