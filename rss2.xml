<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>阿卡丽的黑心商店</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>上古时代的宝贝开卖了！</description>
    <pubDate>Mon, 15 Aug 2022 13:49:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>图的表示方法</title>
      <link>http://example.com/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</link>
      <guid>http://example.com/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Tue, 23 Aug 2022 13:46:57 GMT</pubDate>
      
      <description>&lt;p&gt;邻接矩阵法、十字链表法、邻接表法、邻接多重表的定义以及代码实现的学习以及其之间的比较&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>邻接矩阵法、十字链表法、邻接表法、邻接多重表的定义以及代码实现的学习以及其之间的比较</p><span id="more"></span><h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130207218.png" alt="image-20220806130207218"><br>有向图：出度为行中1的个数  入度为列中1的个数 。矩阵是行-&gt;列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                      <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                   <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];     <span class="comment">//邻接矩阵、边表  //因为数据为0，1，可以换为bool型</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                        <span class="comment">//图当前的顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph</span><br></pre></td></tr></table></figure><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806130727614.png" alt="image-20220806130727614"></p><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131031260.png" alt="image-20220806131031260"><br>使用宏定义常量表示无穷   #define INFINITY</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>$$<br>在n个顶点的图中，空间复杂度为O(n)+O(n^2)&#x3D;O(|v|^2),|v|为顶点集的个数\<br>所以空间复杂度与边数没有关系，更适合用于存储稠密图，因为无向图的邻接矩阵是对称矩阵，所以可以压缩为上三角矩阵进行存储<br>$$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806131810061.png" alt="image-20220806131810061"></p><h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806134053572.png" alt="image-20220806134053572"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表存储的图（顺序存储） </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;               <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                <span class="comment">//第一条边</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;                    <span class="comment">//边指向的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>           <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                //边权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无向图边结点数量是2|E|，整体空间复杂度为O(|V|+2|E|)<br>有向图边结点数量是|E|，整体空间复杂度为O(|V|+|E|)<br>邻接表存储稀疏图<br>出度：遍历目标结点的链表<br>入度：遍历整个链表寻找指向目标结点的个数</p><h2 id="十字链表、邻接多重表"><a href="#十字链表、邻接多重表" class="headerlink" title="十字链表、邻接多重表"></a>十字链表、邻接多重表</h2><p>十字链表用于存储有向图<br>邻接多重表存储无向图</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表<img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140152515.png" alt="image-20220806140152515"></h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图：每条边对于两份冗余数据，删除，删除顶点、边不方便<br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140736457.png" alt="image-20220806140736457"><br><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806140750826.png" alt="image-20220806140750826"><br>空间复杂度：O(|V|+|E|)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/image-20220806141213425.png" alt="image-20220806141213425"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2022/08/23/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>图的基本操作</title>
      <link>http://example.com/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Mon, 22 Aug 2022 13:49:56 GMT</pubDate>
      
      <description>&lt;p&gt;图的几个基本操作函数总结&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>图的几个基本操作函数总结</p><span id="more"></span><h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="Adjacent-G-x-y"><a href="#Adjacent-G-x-y" class="headerlink" title="Adjacent(G,x,y)"></a>Adjacent(G,x,y)</h3><p>判断图G是否存在边&lt;x,y&gt;(x,y)<br>该操作邻接矩阵更合适</p><h3 id="Neighbors-G-x"><a href="#Neighbors-G-x" class="headerlink" title="Neighbors(G,x)"></a>Neighbors(G,x)</h3><p>列出图G与结点x邻接的边<br>该操作一般情况下邻接矩阵更合适</p><h3 id="InsertVertex-G-x"><a href="#InsertVertex-G-x" class="headerlink" title="InsertVertex(G,x)"></a>InsertVertex(G,x)</h3><p>在图G中插入顶点x<br>在邻接矩阵和邻接表中都是在最后插入新的数据</p><h3 id="DeleteVertex-G-x"><a href="#DeleteVertex-G-x" class="headerlink" title="DeleteVertex(G,x)"></a>DeleteVertex(G,x)</h3><p>从图G中删除顶点x<br>邻接矩阵：删除一个顶点之后，将对应的行和列重置为0，可以设置一个bool变量表示是一个空结点</p><h3 id="AddEdge-G-x-y"><a href="#AddEdge-G-x-y" class="headerlink" title="AddEdge(G,x,y)"></a>AddEdge(G,x,y)</h3><p>若无向边（x,y)或者有向边&lt;x,y&gt;不存在，则向图G中添加该边<br>邻接表可以使用头插法，时间复杂度为O(1)</p><h3 id="FirstNeighbor-G-x"><a href="#FirstNeighbor-G-x" class="headerlink" title="FirstNeighbor(G,x)"></a>FirstNeighbor(G,x)</h3><p>求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2022/08/22/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>图</title>
      <link>http://example.com/2022/08/22/%E5%9B%BE/</link>
      <guid>http://example.com/2022/08/22/%E5%9B%BE/</guid>
      <pubDate>Mon, 22 Aug 2022 13:43:24 GMT</pubDate>
      
      <description>&lt;p&gt;有向图无向图简单图多重图连通图强连通图子图的定义，以及图中顶点的度连通分量，边的权和图与树森林的关系和转化，特殊形态的图的学习&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>有向图无向图简单图多重图连通图强连通图子图的定义，以及图中顶点的度连通分量，边的权和图与树森林的关系和转化，特殊形态的图的学习</p><span id="more"></span><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205115991.png"><br>图的边集可以为空集，边集可以有方向也可以没方向</p><p><strong>图逻辑结构的应用</strong><br>微信好友关系     地铁站（顶点集）铁路</p><h3 id="无向图，有向图"><a href="#无向图，有向图" class="headerlink" title="无向图，有向图"></a>无向图，有向图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205427477.png"><br>无向图边集用（)  有向图边集用&lt;&gt;</p><h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803205904593.png"></p><h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>无向图：<strong>顶点v的度</strong>是该顶点边的条数，记为TD(v)<br>有向图：<strong>顶点v的入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)<br>              <strong>顶点v的出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)<br>              <strong>顶点v的度</strong>等于入度和出度的和，即TD(v)&#x3D;ID(v)+OD(v)<br>$$<br>n个顶点，e条边\无向图：\sum_{i&#x3D;1}^{n}TD(v_i)&#x3D;2e\有向图：\sum_{i&#x3D;1}^nID(v_i)&#x3D;\sum_{i&#x3D;1}^nOD(v_i)&#x3D;e<br>$$</p><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><p>路径——顶点A到顶点E之间的一条路径是指顶点序列（A,B,C,D,E)<br>回路—— 第一个顶点和最后一个顶点相同的路径称为<strong>回路或者环</strong><br>简单路径——路径序列中顶点不重复出现的路径<br>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现<br>路径长度——路径上边的数目<br>点到点的距离——最短路径的长度（若不存在路径记为无穷）<br>无向图中，若从顶点v到顶点w有路径存在，则成v和w是连通的<br>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p><h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><p>无向图：若图G任意两个顶点都是连通的，则称图G为连通图，否则为非连通图<br>有向图：若图G任何一对顶点都是强连通的，则称此图为强连通图</p><p>$$<br>常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边。\若G是非连通图，则最多可能有C_{n-1}^2条边\对于有n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）<br>$$</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223621217.png"></p><h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803223755599.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223815794.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803223952245.png"></p><h3 id="生成树、森林"><a href="#生成树、森林" class="headerlink" title="生成树、森林"></a>生成树、森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224238846.png"><br>n个顶点应该有n-1条边<br>在非连通图中，连通分量的生成树构成了非连通图的生成森林<br><img src="/2022/08/22/%E5%9B%BE/image-20220803224538347.png"></p><h3 id="边的权、带权图-x2F-网"><a href="#边的权、带权图-x2F-网" class="headerlink" title="边的权、带权图&#x2F;网"></a>边的权、带权图&#x2F;网</h3><p>边的权：每条边都可以标上具用某种含义的数值，该数值称为该边的<strong>权值</strong>。<br>带权图&#x2F;网：边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong><br>带权路径长度：当图是带权图时，一条<strong>路径上所有边的权值之和</strong></p><h3 id="特殊形态的图"><a href="#特殊形态的图" class="headerlink" title="特殊形态的图"></a>特殊形态的图</h3><p><img src="/2022/08/22/%E5%9B%BE/image-20220803225437195.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225522718.png"><br><img src="/2022/08/22/%E5%9B%BE/image-20220803225858050.png"><br>树是连通图，有向树并不是强连通图</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2022/08/22/%E5%9B%BE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>平衡二叉树以及哈夫曼树和哈夫曼编码</title>
      <link>http://example.com/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Sun, 21 Aug 2022 13:39:47 GMT</pubDate>
      
      <description>&lt;p&gt;平衡二叉树转换的四种情况解析以及代码实现。哈夫曼树以及哈夫曼编码的原理&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>平衡二叉树转换的四种情况解析以及代码实现。哈夫曼树以及哈夫曼编码的原理</p><span id="more"></span><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1<br><strong>结点的平衡因子</strong>&#x3D;左子树高-右子树高<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234821736.png"></p><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709234957697.png"></p><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235020317.png"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235353920.png" alt="image-20220709235353920"><br>假设的子树的高度一定都是统一的一个值H</p><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235550956.png"></p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709235832689.png"></p><h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000110322.png"></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000356369.png"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000444260.png"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000533083.png"></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710000716645.png"></p><p><strong>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复</strong></p><h3 id="查找效率问题"><a href="#查找效率问题" class="headerlink" title="查找效率问题"></a>查找效率问题</h3><h3 id="最坏时间复杂度O-h"><a href="#最坏时间复杂度O-h" class="headerlink" title="最坏时间复杂度O(h)"></a>最坏时间复杂度O(h)</h3><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001904807.png"><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001932928.png" alt="image-20220710001932928"><br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710001948415.png" alt="image-20220710001948415"></p><p><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002053754.png"></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的权：有某种现实含义（如：表示节点的重要性）<br>结点的带权路径长度：从树的跟到该结点的路径长度（经过的边数）与该结点上权值的乘积<br>树的带权路径长度（WPL)：书中所有的叶子结点的带权路径长度之和<br><img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710002632003.png"><br>哈夫曼树的结点总数为2n-1<br>哈夫曼树中不存在度为1的结点<br>哈夫曼树并不唯一，但WPL必然相同且为最优</p><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码——每个字都用相等长度的二进制位表示（ASCII编码）</p><p>可变长度编码<img src="/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220710003458543.png"><br>前缀编码：没有一个编码是另一个编码的前缀</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      <category domain="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</category>
      
      
      <comments>http://example.com/2022/08/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉排序树</title>
      <link>http://example.com/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</link>
      <guid>http://example.com/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</guid>
      <pubDate>Sun, 21 Aug 2022 13:36:59 GMT</pubDate>
      
      <description>&lt;p&gt;二叉排序树的原理以及基本操作&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>二叉排序树的原理以及基本操作</p><span id="more"></span><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>二叉查找树<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231736496.png"><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231745186.png"><br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709231900686.png"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=null&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="comment">//时间复杂度O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);   <span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);   <span class="comment">//在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(h)</span></span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232619239.png"><br>注意插入操作是引用类型<br>最坏空间复杂度O(h)</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709232821433.png"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233303115.png"></p><h2 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h2><p>查找成功的平均长度ASL<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709233912561.png"><br>$$<br>尽可能达到O(log_2n)<br>$$<br>查找失败的平均查找长度<br><img src="/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20220709234322040.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/21/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树和森林的遍历</title>
      <link>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <guid>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <pubDate>Fri, 19 Aug 2022 09:04:20 GMT</pubDate>
      
      <description>&lt;p&gt;树的先根后根层次遍历和森林的先序后序遍历的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>树的先根后根层次遍历和森林的先序后序遍历的代码实现</p><span id="more"></span><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p><h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709230748352.png"></p><p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231031413.png"><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p><h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231345040.png"><br>可以先转换成二叉树，在对二叉树进行先序遍历</p><h3 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231520092.png"></p><p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231626512.png"></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树的逻辑结构</title>
      <link>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</link>
      <guid>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Thu, 18 Aug 2022 09:00:05 GMT</pubDate>
      
      <description>&lt;p&gt;使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。</p><span id="more"></span><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709211533787.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709212419211.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure><h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213548106.png"><br><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213700619.png" alt="image-20220709213700619"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线索二叉树</title>
      <link>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Thu, 18 Aug 2022 08:56:17 GMT</pubDate>
      
      <description>&lt;p&gt;构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继</p><span id="more"></span><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200423798.png"></p><h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200709261.png"><br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200930693.png"></p><h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709204642583.png"></p><h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205639652.png"><br>该方法的时间复杂度是O（1)</p><h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205928279.png"></p><h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210518474.png"></p><h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211254569.png"></p><h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag&#x3D;&#x3D;0，则一定有右孩子，所以只能用土办法来找</p><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210913690.png"></p><p>p为根节点则没有后序后继</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211007944.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树</title>
      <link>http://example.com/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Wed, 17 Aug 2022 08:53:35 GMT</pubDate>
      
      <description>&lt;p&gt;二叉树的存储结构和链式存储的代码实现、遍历的代码实现和层序遍历构造二叉树的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>二叉树的存储结构和链式存储的代码实现、遍历的代码实现和层序遍历构造二叉树的代码实现</p><span id="more"></span><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是有序树（左右子树不能颠倒）递归定义的数据结构</p><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701141656221.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142020842.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142503488.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709114958544.png"></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];<span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次存储完全二叉树的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120058958.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120134485.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120216992.png"></p><h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">ElemType data;                     <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>            <span class="comment">//父节点指针（三叉链表——方便找父节点）</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709121942852.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一颗空树</span></span><br><span class="line">BiTree root =null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = null;</span><br><span class="line">root-&gt;rchild = null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = null;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709125146274.png"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130230793.png"></p><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130623105.png"></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);            <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//递归遍历右子树0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(h)</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192542556.png"><br>先序遍历——第一次路过时访问结点<br>中序遍历——第二次路过时访问结点<br>后序遍历——第三次路过时访问结点<br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192656825.png"></p><h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    IF(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709193412735.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode * data;           <span class="comment">//存指针而不是结点来节省空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);  <span class="comment">//初始化</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);    <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);   <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);       <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>给定一个前中后序遍历序列可能对应多种二叉树<br>给定中序加一种其他序（前序后序层序）对应唯一二叉树</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql注入</title>
      <link>http://example.com/2022/08/17/sql%E6%B3%A8%E5%85%A5/</link>
      <guid>http://example.com/2022/08/17/sql%E6%B3%A8%E5%85%A5/</guid>
      <pubDate>Wed, 17 Aug 2022 02:29:44 GMT</pubDate>
      
      <description>&lt;p&gt;SQL是操作数据库数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证(即存在注入点)就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>SQL是操作数据库数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证(即存在注入点)就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击。</p><span id="more"></span><h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><p>首先先看看输出<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105442755.png"><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105456531.png"><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105510464.png"><br>通过代码可以看到表单输入id没有任何过滤<img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817105528953.png"></p><h3 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110157425.png"><br>受引号闭合影响<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110321644.png"><br>或者在url栏输入<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110448845.png"><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110527094.png"><br>是等价的</p><h3 id="判断字段"><a href="#判断字段" class="headerlink" title="判断字段"></a>判断字段</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110631637.png"><br>order by 3时报错<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110650685.png"><br>2是正确的3返回错误，即有两个字段<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817110944135.png"></p><h3 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817111143792.png"></p><h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><p>因为information_schema的排序规则是utf8_general_ci,而dvwa中排序规则是utf8_unicode_ci,需要逐一更改每个字段；或者直接使用16进制读取然后解码</p><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817112730977.png"><br>用burp自带的解码器用ASCLL hex解码<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817113057326.png"><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817113146151.png"><br>得到表名是guestbook和users<br>也可以通过group_concat将表名拼接起来<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817143345283.png"></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>mysql5.0及以上版本中自带数据库information_schema,用来存储所有数据库名、表名、列名。</p><h3 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817143842352.png"><br>ASCLL hex解密<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817144040718.png"></p><h3 id="查询自己想知道的"><a href="#查询自己想知道的" class="headerlink" title="查询自己想知道的"></a>查询自己想知道的</h3><p>比如user、password<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817144933961.png"><br>使用md5解密第一个来验证，确实是登录时候用的账号密码<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145151291.png"></p><h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145813710.png"></p><p>可以看到他不给写东西了只可以下来表单，通过burp来进行sql注入，步骤和上面一样，注入位置是抓到的包的id，下图最后一行<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817145942734.png"></p><h3 id="注入点判断-1"><a href="#注入点判断-1" class="headerlink" title="注入点判断"></a>注入点判断</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150024751.png"><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150059469.png" style="zoom:50%;"></p><h3 id="判断字段-1"><a href="#判断字段-1" class="headerlink" title="判断字段"></a>判断字段</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150519477.png"><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150647418.png"><br>没返回错误代表有两个字段<br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150754237.png"><br><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150802608.png"><br>证明字段数为2</p><h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151035776.png"><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817150945392.png"></p><h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151935877.png"><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817151734964.png"></p><p>这里table_schema&#x3D;’dvwa’变成了0x64767761是因为源代码中有mysqli_real_escape_string函数，会将特殊符号转义，可以通过将引号内的内容转换成16进制跳过该函数</p><h3 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152559684.png"><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152530263.png"></p><h3 id="获取想知道的"><a href="#获取想知道的" class="headerlink" title="获取想知道的"></a>获取想知道的</h3><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152859329.png"><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817152916391.png"></p><h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><p>跳转到另一个页面</p><p><img src="/2022/08/17/sql%E6%B3%A8%E5%85%A5/image-20220817153035328.png"><br>经过多次尝试发现语法和low级别是一样的<br>源代码中多了limit函数限制一行输出，只要#注释掉就ok，应该是用来防治sqlmap一把梭的</p><h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    <span class="title function_ invoke__">checkToken</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered?</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_numeric</span>( <span class="variable">$id</span> )) &#123;</span><br><span class="line">        <span class="comment">// Check the database</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">prepare</span>( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> );</span><br><span class="line">        <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">bindParam</span>( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::<span class="variable constant_">PARAM_INT</span> );</span><br><span class="line">        <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">        <span class="variable">$row</span> = <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure only 1 result is returned</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="variable">$data</span>-&gt;<span class="title function_ invoke__">rowCount</span>() == <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">// Get values</span></span><br><span class="line">            <span class="variable">$first</span> = <span class="variable">$row</span>[ <span class="string">&#x27;first_name&#x27;</span> ];</span><br><span class="line">            <span class="variable">$last</span>  = <span class="variable">$row</span>[ <span class="string">&#x27;last_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for end user</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line"><span class="title function_ invoke__">generateSessionToken</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和暴力破解的impossible一样都使用了PDO技术，划清了代码与数据的界限，有效防御sql注入，同时只有返回查询的结果数量为1时才会成功输出，而Anti-CSRFtoken的加入进一步提高了安全性</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/web%E6%94%BB%E9%98%B2/">web攻防</category>
      
      <category domain="http://example.com/tags/sql%E6%B3%A8%E5%85%A5/">sql注入</category>
      
      
      <comments>http://example.com/2022/08/17/sql%E6%B3%A8%E5%85%A5/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
