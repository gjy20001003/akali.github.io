<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>阿卡丽的黑心商店</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>上古时代的宝贝开卖了！</description>
    <pubDate>Sun, 14 Aug 2022 08:15:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>吐槽</title>
      <link>http://example.com/2022/08/14/%E5%90%90%E6%A7%BD/</link>
      <guid>http://example.com/2022/08/14/%E5%90%90%E6%A7%BD/</guid>
      <pubDate>Sun, 14 Aug 2022 08:10:47 GMT</pubDate>
      
      <description>&lt;p&gt;日常吐槽&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>日常吐槽</p><span id="more"></span><p>在往博客上写东西的时候，接到家里的电话，接了之后蹦了一句你是不是在玩游戏，我直接不知道怎么接了，难搞</p><p><img src="/2022/08/14/%E5%90%90%E6%A7%BD/image-20220814161527134.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E9%9A%8F%E7%AC%94%EF%BC%8C%E5%90%90%E6%A7%BD/">随笔，吐槽</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%90%90%E6%A7%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>矩阵</title>
      <link>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/</link>
      <guid>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/</guid>
      <pubDate>Sun, 14 Aug 2022 07:37:01 GMT</pubDate>
      
      <description>&lt;p&gt;矩阵的存储代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>矩阵的存储代码实现</p><span id="more"></span><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>ElemType a[10];    &#x2F;&#x2F;ElemType型一维数组</p><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194725210.png"></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>ElemType b[2] [4]    &#x2F;&#x2F;2行4列的二维数组</p><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194843476.png"></p><p>起始地址：LOC</p><p>行优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603194958977.png"></p><p>列优先存储地址计算<img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195101464.png"></p><p>二维数组也具有随机存储的性质</p><h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195510230.png"></p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603195836998.png" style="zoom:67%;"><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200202029.png"></p><h3 id="三对角矩阵（带状矩阵）"><a href="#三对角矩阵（带状矩阵）" class="headerlink" title="三对角矩阵（带状矩阵）"></a>三对角矩阵（带状矩阵）</h3><p>  <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603200953049.png"></p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201426822.png" style="zoom:80%;"><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素的个数远远少于矩阵元素的个数</p><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201607063.png" style="zoom:50%;"><p> <img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201638617.png" style="zoom: 80%;"><img src="/2022/08/14/%E7%9F%A9%E9%98%B5/image-20220603201828331-16604628178811.png" style="zoom: 67%;"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%9F%A9%E9%98%B5/">矩阵</category>
      
      
      <comments>http://example.com/2022/08/14/%E7%9F%A9%E9%98%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>栈和队列的应用</title>
      <link>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <guid>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:32:15 GMT</pubDate>
      
      <description>&lt;p&gt;栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>栈和队列的应用，如括号匹配，表达式值中的应用，递归，树、图的遍历等</p><span id="more"></span><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>IDE:可视化的编程环境</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180407947-16604625560341.png" style="zoom:67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603180507316.png" style="zoom:67%;"></p><p>扫描到左括号就入栈，扫描到右括号就出栈进行匹配 </p><p>代码实现</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603182409614.png"></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603183310686.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603184904342.png"></p><p>先出栈的是右操作数，后出栈的是左操作数 </p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603191739417.png"></p><h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192451544.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192500473.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603192716850.png"></p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603193038318.png"></p><p>递归调用时，函数调用栈可称为递归工作栈</p><p>递归算法的缺点：太多层递归可能导致栈溢出。可能包含多次重复计算</p><h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p>具体查看树的章节</p><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3><p>具体查看图的章节</p><h3 id="在操作系统中的应用"><a href="#在操作系统中的应用" class="headerlink" title="在操作系统中的应用"></a>在操作系统中的应用</h3><p>FCFS(First Come First Service)先来先服务的策略</p><p>eg1：</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194341970.png"></p><p>轮流获得cpu的服务</p><p>eg2：</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/image-20220603194439959.png"></p><p>可缓解主机域打印机速度不匹配的问题</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      <category domain="http://example.com/tags/%E9%98%9F%E5%88%97/">队列</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>队列</title>
      <link>http://example.com/2022/08/14/%E9%98%9F%E5%88%97/</link>
      <guid>http://example.com/2022/08/14/%E9%98%9F%E5%88%97/</guid>
      <pubDate>Sun, 14 Aug 2022 07:25:53 GMT</pubDate>
      
      <description>&lt;p&gt;队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>队列的定义，以及队列的顺序存储结构和链式存储结构的代码实现以及部分操作,双端队列的定义</p><span id="more"></span><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>只允许在一端插入，在另一端删除的线性表</p><p>入队：插入     eg：打饭，高速过闸口</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603163038483.png"></p><p>插入的一段为队尾，删除的一端为队头</p><p>队列的特点：先进先出（First In First Out)(FIFO)</p><p>栈的特点：后进先出（LIFO）</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603163231846.png"></p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序实现-初始化和判空操作"><a href="#队列的顺序实现-初始化和判空操作" class="headerlink" title="队列的顺序实现,初始化和判空操作"></a>队列的顺序实现,初始化和判空操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];     <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;             <span class="comment">//队头队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front = Q.rear =<span class="number">0</span>;    <span class="comment">//初始时 队头队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个队列（顺序存储）</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="comment">//。。。后续操作。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;    <span class="comment">//队尾指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队操作和查询队头操作"><a href="#出队操作和查询队头操作" class="headerlink" title="出队操作和查询队头操作"></a>出队操作和查询队头操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,Elemtype &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front =(Q.front+<span class="number">1</span>)%MaxSize;   <span class="comment">//删除这一句后就是查询队头操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断队列已满-x2F-已空-x2F-元素个数"><a href="#判断队列已满-x2F-已空-x2F-元素个数" class="headerlink" title="判断队列已满&#x2F;已空&#x2F;元素个数"></a>判断队列已满&#x2F;已空&#x2F;元素个数</h3><p>元素个数：（rear+MaxSize-front)%MaxSize</p><p>方案一：</p><p>已满：(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front</p><p>已空：Q.rear &#x3D;&#x3D; Q.front</p><p>方案二：</p><p>增加一个变量 int size  插入成功 size++ 删除成功size – 初始化  size&#x3D;0</p><p>队满条件：size&#x3D;&#x3D;MaxSize    队空条件：size &#x3D;&#x3D;0</p><p>方案三：</p><p>增加一个变量tag（最近进行的是删除赋值为0，插入赋值为1，初始化tag&#x3D;0）</p><p>原理：只有删除操作才可能导致队空，只有插入操作才可能导致队满</p><p>队满条件：front&#x3D;&#x3D;rear&amp;&amp;tag&#x3D;1 </p><p>队空条件：front&#x3D;&#x3D;rear&amp;&amp;tag&#x3D;0</p><h3 id="其他出题方法"><a href="#其他出题方法" class="headerlink" title="其他出题方法"></a>其他出题方法</h3><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603170120078.png"></p><p>初始化的时候设置rear&#x3D;MaxSize-1 front&#x3D;0</p><p><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603170229143.png" style="zoom: 67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603170342160-16604622170741.png" style="zoom: 67%;"></p><p>判空：方案一：牺牲一个存储单元</p><pre><code>       方案二：设置变量tag或size</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="链式实现及初始化"><a href="#链式实现及初始化" class="headerlink" title="链式实现及初始化"></a>链式实现及初始化</h3><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时front，rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603171845086.png" style="zoom: 67%;"><h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603172140271.png" style="zoom:80%;"><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=s;     <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;           <span class="comment">//修改rear指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=null;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q。rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q,rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;             <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;                      <span class="comment">//变量x返回头元素</span></span><br><span class="line">    Q.front=p-&gt;next;          <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)                   <span class="comment">//最后一个结点出队</span></span><br><span class="line">        Q.rear=null;              <span class="comment">//front指向null</span></span><br><span class="line">        Q.front=null;             <span class="comment">//修改rear指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p);                        <span class="comment">//释放节点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列满的情况"><a href="#队列满的情况" class="headerlink" title="队列满的情况"></a>队列满的情况</h3><p>链式存储——一般不会队满，除非内存不足</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603174425521.png" style="zoom: 67%;"><img src="/2022/08/14/%E9%98%9F%E5%88%97/image-20220603174505573.png" style="zoom:67%;">]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E9%98%9F%E5%88%97/">队列</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%98%9F%E5%88%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>栈</title>
      <link>http://example.com/2022/08/14/%E6%A0%88/</link>
      <guid>http://example.com/2022/08/14/%E6%A0%88/</guid>
      <pubDate>Sun, 14 Aug 2022 07:21:44 GMT</pubDate>
      
      <description>&lt;p&gt;s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>s栈的初步理解以及顺序栈和链栈定义和基本操作的代码实现</p><span id="more"></span><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈（stack）是值允许在一端进行插入或者删除操作的线性表</p><img src="/2022/08/14/%E6%A0%88/image-20220602162636874.png" style="zoom:50%;"><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><p>空栈，栈顶 ，栈底<img src="/2022/08/14/%E6%A0%88/image-20220602162853052.png"></p><p>逻辑结构：与普通线性表相同</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p><img src="/2022/08/14/%E6%A0%88/image-20220602163140637.png"></p><p>进栈和出栈</p><img src="/2022/08/14/%E6%A0%88/image-20220602163335955.png" style="zoom:80%;"><h2 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h2><h3 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10                  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];         <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                        <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                        <span class="comment">//初始化栈顶指针         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为初始化是s.top=-1</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">SqStack S;   <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">    <span class="comment">//..后续操作。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p><h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)   <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;        <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top]=x;        <span class="comment">//新元素入栈       //替换为S.data[++S.top]=x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈和读栈顶元素操作"><a href="#出栈和读栈顶元素操作" class="headerlink" title="出栈和读栈顶元素操作"></a>出栈和读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top = S.top <span class="number">-1</span>;        <span class="comment">//x=S.data[S.top--]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>top &#x3D; 0时，栈满时top&#x3D;maxsize&#x3D;10</p><p>top &#x3D; -1时，栈满是top&#x3D;9</p><p>二者的入栈出栈操作正好是翻过来</p><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10              <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MaxSize];     <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                   <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                   <span class="comment">//一号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top=MaxSize;</span><br><span class="line">&#125;                              <span class="comment">//栈满的条件：top0 + 1 == top1</span></span><br></pre></td></tr></table></figure><img src="/2022/08/14/%E6%A0%88/image-20220603162012226.png" style="zoom: 50%;"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/14/%E6%A0%88/image-20220603161547608.png"></p><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>用链式存储的栈也是一种单链表，只是在插入和删除进行了限制，例如头插法就是入栈，删除第一个结点就是出栈</p><h3 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/14/%E6%A0%88/image-20220603162308266.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%88/">栈</category>
      
      
      <comments>http://example.com/2022/08/14/%E6%A0%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>顺序表和链表的比较</title>
      <link>http://example.com/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <guid>http://example.com/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <pubDate>Sun, 14 Aug 2022 07:18:12 GMT</pubDate>
      
      <description>&lt;p&gt;对前几篇的总结，比较线性表中顺序表和链表的异同&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>对前几篇的总结，比较线性表中顺序表和链表的异同</p><span id="more"></span><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>都属于线性表，都是线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序表</strong>   优点：支持随机存取，存储密度高</p><pre><code>          缺点：大片连续空间分配不方便，改变容量不方便</code></pre><p><strong>链表</strong>       优点：离散的小空间分配方便，改变不容量方便</p><pre><code>           缺点：不可随机存取，存储密度低</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创销 增删改查</p><h4 id="创"><a href="#创" class="headerlink" title="创"></a>创</h4><p>顺序表：预分配大片连续空间。静态分配：静态数组（空间大小不可改变）。动态分配：动态数组（malloc，free函数，但需要大量移动数据）</p><p>链表：只需分配一个头结点（或者头指针）</p><h4 id="销"><a href="#销" class="headerlink" title="销"></a>销</h4><p>顺序表：修改length&#x3D;0，静态数组：系统自动回收空间。动态数组：需要手动free</p><p>链表：一次删除各个结点（free）</p><p><img src="/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519211257486.png"></p><h4 id="增，删"><a href="#增，删" class="headerlink" title="增，删"></a>增，删</h4><p>顺序表：移动元素，时间复杂度O(n),时间花销主要来自移动元素</p><p>链表：修改指针，时间复杂度O(n),时间花销来自查找目标元素</p><p>链表的效率比顺序表高得多</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>顺序表：按位查找：O(1)</p><pre><code>          按位查找：O(n)，若表内元素有序，可在</code></pre><p>$$<br>O(log_2n)<br>$$<br>时间内找到</p><p>链表: 按位查找：O(n)</p><pre><code>     按值查找：O(n)</code></pre><p>顺序表效率更好</p><p><img src="/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212208066-16604616041971.png"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>表长难以预估，经常要增加&#x2F;删除元素 ——链表</p><p>表长可以预估，查询（搜索）操作较多  ——顺序表</p><h3 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h3><p><img src="/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/image-20220519212403852.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>静态链表</title>
      <link>http://example.com/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:15:15 GMT</pubDate>
      
      <description>&lt;p&gt;静态链表的定义初始化基本操作的原理和代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>静态链表的定义初始化基本操作的原理和代码实现</p><span id="more"></span><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分配一整片连续的内存空间，各个结点集中安置</p><p><img src="/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/image-20220519204020786.png"></p><p>游标为-1表示以及到达表尾</p><p>游标充当指针</p><p>计算：每个数据元素4B，每个游标4B，设起始地址为addr，e1的地址为：<br>$$<br>addr+8B*2<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>     <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;   <span class="comment">//存放数据元素</span></span><br><span class="line">    <span class="type">int</span> next;        <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;    <span class="comment">//a看起来是一个静态链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//a看起来是一个node型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将a[0]的next设置为-1</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发遍历结点</p><p>时间复杂度为O(n)</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>(1)找到一个空的结点，存入数据元素</p><p>(2)从头结点出发找到位序为i-1的结点</p><p>(3)修改新结点的next</p><p>(4)修改i-号结点的next</p><p>如何判断为空？————可以让next设置为特殊值</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>(1)从头结点出发找到前驱结点</p><p>(2)修改前驱结点的游标</p><p>(3)被删除的结点next设为-2</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表：用数组的方式实现的链表</p><p>逻辑上相邻的元素可以在物理上不相邻</p><p>优点：增删操作不需要大量移动元素</p><p>缺点：不能随机存取，固定容量不可变</p><p>使用场景：不支持指针的低级语言。数据元素数量固定不变的场景（操作系统的文件分配表）</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>循环链表</title>
      <link>http://example.com/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 07:12:40 GMT</pubDate>
      
      <description>&lt;p&gt;循环单链表和循环双链表的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>循环单链表和循环双链表的代码实现</p><span id="more"></span><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>分为：循环单链表，循环双链表</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519201322333.png"></p><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="定义循环单链表"><a href="#定义循环单链表" class="headerlink" title="定义循环单链表"></a>定义循环单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>         <span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;            <span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==null)                 <span class="comment">//内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;                   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> Empty(LinkList L)&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNide *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环单链表可以从任意一个点出发找到任何一个结点</p><p>应用场景：在项目中需要经常对表头和表尾进行操作</p><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202518705.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202611055.png"></p><p>示意图</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202626494.png"></p><p>判空</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202646358.png"></p><p>寻找表尾</p><p><img src="/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/image-20220519202653076.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双链表</title>
      <link>http://example.com/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/</link>
      <guid>http://example.com/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 14 Aug 2022 03:30:56 GMT</pubDate>
      
      <description>&lt;p&gt;双链表的初始化、基本操作和遍历&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>双链表的初始化、基本操作和遍历</p><span id="more"></span><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化（带头结点）"><a href="#初始化（带头结点）" class="headerlink" title="初始化（带头结点）"></a>初始化（带头结点）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = null;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174125025.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>后插操作</p><p><img src="/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174230546.png"></p><p><img src="/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/image-20220519174327671.png"></p><p>前插操作：通过双链表的特性可以找到插入位置的前一个结点，再对该结点进行后插操作</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeketeNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==null)          <span class="comment">//p没有后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=null)</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="销毁双链表"><a href="#销毁双链表" class="headerlink" title="销毁双链表"></a>销毁双链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != null)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);   <span class="comment">//释放头结点</span></span><br><span class="line">    L=null;    <span class="comment">//头指针指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg按位查找按值查找打印等</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior != null)&#123;</span><br><span class="line">p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度:O(n)</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%8F%8C%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单链表的基本操作</title>
      <link>http://example.com/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Sun, 14 Aug 2022 03:15:03 GMT</pubDate>
      
      <description>&lt;p&gt;单链表的插入删除和查找操作的原理解析和代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>单链表的插入删除和查找操作的原理解析和代码实现</p><span id="more"></span><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p>带头结点</p><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519145908546.png"></p><p>if i &#x3D; 6 : p指向NULL，则第i-1节点不存在，直接返回false</p><p>时间复杂度：O(n)</p><p>不带头节点</p><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519150604589.png"></p><p>不带头结点需要一段单独的代码来应对i&#x3D;1的情况</p><h4 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,* LinkList</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InserNextNode</span> <span class="params">(LNode *p ,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)               <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;              <span class="comment">//结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode *p;</span><br><span class="line">   <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p! = <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p>两种方法：（1)传入头节点，依次遍历（2）采用后插方式，将节点p的值赋给新申请的节点，将插入的值赋给节点p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insertpriornode</span> <span class="params">(LNode *p, ElemTyoe e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;            <span class="comment">//新结点s连到p结点后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;      <span class="comment">//将p中元素赋值给s</span></span><br><span class="line">    p-&gt;data=e;            <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519153009590.png"></p><p>时间复杂度：O(1)</p><h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519154105544.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">listdelete</span><span class="params">(linklist &amp;L,<span class="type">int</span> i,elemtype &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q=p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好时间复杂度：O(1)</p><p>最坏&#x2F;平均时间复杂度：O(n)</p><h4 id="指定节点的删除"><a href="#指定节点的删除" class="headerlink" title="指定节点的删除"></a>指定节点的删除</h4><p>下面例子为带头结点的单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">deletenode</span> <span class="params">(lnode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p--<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    lnode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>如果p是最后一个节点，只能依次寻找p的前驱，时间复杂度为O(n)</p><h3 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h3><p><img src="/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220519162949205.png"></p><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均时间复杂度：O(n)</p><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="type">int</span> len =<span class="number">0</span>;           <span class="comment">//统计表长</span></span><br><span class="line">LNode *p = L;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/">顺序表</category>
      
      <category domain="http://example.com/tags/%E9%93%BE%E8%A1%A8/">链表</category>
      
      
      <comments>http://example.com/2022/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
