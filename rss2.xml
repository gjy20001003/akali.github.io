<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>阿卡丽的黑心商店</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>上古时代的宝贝开卖了！</description>
    <pubDate>Sun, 14 Aug 2022 09:08:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>树和森林的遍历</title>
      <link>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <guid>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <pubDate>Fri, 19 Aug 2022 09:04:20 GMT</pubDate>
      
      <description>&lt;p&gt;树的先根后根层次遍历和森林的先序后序遍历的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>树的先根后根层次遍历和森林的先序后序遍历的代码实现</p><span id="more"></span><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=null)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的先根遍历与二叉树的先序遍历相同<br>深度优先遍历</p><h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709230748352.png"></p><p>树的后根遍历与二叉树的中序遍历相同<br>深度优先遍历</p><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231031413.png"><br>树的层次遍历与二叉树的层序遍历相同<br>广度优先遍历</p><h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p> <img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231345040.png"><br>可以先转换成二叉树，在对二叉树进行先序遍历</p><h3 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h3><p><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231520092.png"></p><p>可以先转换成二叉树，在对二叉树进行中序遍历<br><img src="/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/image-20220709231626512.png"></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/19/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树的逻辑结构</title>
      <link>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</link>
      <guid>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Thu, 18 Aug 2022 09:00:05 GMT</pubDate>
      
      <description>&lt;p&gt;使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>使用双亲表示法孩子表示法以及孩子兄弟表示法表示树的逻辑结构，以及森林和二叉树的转换。</p><span id="more"></span><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709211533787.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709212419211.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;   <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>   <span class="comment">//下一个改组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">fistchild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r    <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree</span><br></pre></td></tr></table></figure><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree</span><br></pre></td></tr></table></figure><h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><p><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213548106.png"><br><img src="/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/image-20220709213700619.png" alt="image-20220709213700619"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/18/%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线索二叉树</title>
      <link>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Thu, 18 Aug 2022 08:56:17 GMT</pubDate>
      
      <description>&lt;p&gt;构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>构建线索二叉树以及通过先序中序后序遍历查找线索二叉树的前驱后继</p><span id="more"></span><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通二叉树不能从任意一个指定结点开始遍历<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200423798.png"></p><h3 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200709261.png"><br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709200930693.png"></p><h3 id="土办法找前驱"><a href="#土办法找前驱" class="headerlink" title="土办法找前驱"></a>土办法找前驱</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode *pre=null;</span><br><span class="line">BiTNode *final-null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;     <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        pre = q;       <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=null;</span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==null)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==null)&#123;</span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=null&amp;&amp;pre-&gt;rchild==null)&#123;</span><br><span class="line">        pre-&gt;rchild=q;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709204642583.png"></p><h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h3 id="中序后继"><a href="#中序后继" class="headerlink" title="中序后继"></a>中序后继</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205639652.png"><br>该方法的时间复杂度是O（1)</p><h3 id="中序前驱"><a href="#中序前驱" class="headerlink" title="中序前驱"></a>中序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709205928279.png"></p><h3 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h3><p>二叉链表没办法找到先序前驱<br>将二叉链表转化为三叉链表<br><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210518474.png"></p><h3 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211254569.png"></p><h3 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h3><p>p.rtag&#x3D;&#x3D;0，则一定有右孩子，所以只能用土办法来找</p><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709210913690.png"></p><p>p为根节点则没有后序后继</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709211007944.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/18/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树</title>
      <link>http://example.com/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <guid>http://example.com/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <pubDate>Wed, 17 Aug 2022 08:53:35 GMT</pubDate>
      
      <description>&lt;p&gt;二叉树的存储结构和链式存储的代码实现、遍历的代码实现和层序遍历构造二叉树的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>二叉树的存储结构和链式存储的代码实现、遍历的代码实现和层序遍历构造二叉树的代码实现</p><span id="more"></span><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是有序树（左右子树不能颠倒）递归定义的数据结构</p><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701141656221.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142020842.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220701142503488.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709114958544.png"></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];<span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次存储完全二叉树的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120058958.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120134485.png"><br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709120216992.png"></p><h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">ElemType data;                     <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>            <span class="comment">//父节点指针（三叉链表——方便找父节点）</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709121942852.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一颗空树</span></span><br><span class="line">BiTree root =null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = null;</span><br><span class="line">root-&gt;rchild = null;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = null;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根结点的左孩子</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709125146274.png"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130230793.png"></p><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709130623105.png"></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);            <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//递归遍历右子树0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(h)</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192542556.png"><br>先序遍历——第一次路过时访问结点<br>中序遍历——第二次路过时访问结点<br>后序遍历——第三次路过时访问结点<br><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709192656825.png"></p><h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    IF(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220709193412735.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode * data;           <span class="comment">//存指针而不是结点来节省空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);  <span class="comment">//初始化</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);    <span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);   <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);       <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>给定一个前中后序遍历序列可能对应多种二叉树<br>给定中序加一种其他序（前序后序层序）对应唯一二叉树</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/17/%E4%BA%8C%E5%8F%89%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树和森林</title>
      <link>http://example.com/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</link>
      <guid>http://example.com/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</guid>
      <pubDate>Tue, 16 Aug 2022 08:50:34 GMT</pubDate>
      
      <description>&lt;p&gt;树的基本概念，有序树与无序树、森林以及其性质&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>树的基本概念，有序树与无序树、森林以及其性质</p><span id="more"></span><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>非空树：有且仅有一个根节点</p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629122020259.png" style="zoom:67%;"><p>空树：节点数为0的树<br>没有后继的结点成为叶子节点（终端节点）<br><strong>除了根节点之外有且仅有一个前驱</strong></p><h3 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h3><p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629122304793.png"></p><p>子树互不相交</p><p><strong>树是一种递归定义的数据结构</strong></p><h3 id="节点之间的路径"><a href="#节点之间的路径" class="headerlink" title="节点之间的路径"></a>节点之间的路径</h3><p>路径是单向的，只能从上往下</p><h3 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h3><p>经过几条边</p><h3 id="结点，树的属性描述"><a href="#结点，树的属性描述" class="headerlink" title="结点，树的属性描述"></a>结点，树的属性描述</h3><p>结点的层次（深度）——从上往下数<br>结点的高度——从下往上数<br>树的高度（深度）——总共多少层<br>结点的度——有几个孩子（分支）<br>树的度——各结点的度的最大值<br>默认从一开始</p><h2 id="有序树vs无序树"><a href="#有序树vs无序树" class="headerlink" title="有序树vs无序树"></a>有序树vs无序树</h2><p><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220629123151781.png"></p><h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林是m棵互不相交的树的集合（m可为0，表示空森林）</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>结点数&#x3D;总度数+1<br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140810203.png"><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140849174.png"><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701140928499.png"><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701141014648.png"><br><img src="/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220701141202675.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">树与二叉树</category>
      
      
      <comments>http://example.com/2022/08/16/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>朴素模式匹配算法和KPM算法</title>
      <link>http://example.com/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/</link>
      <guid>http://example.com/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Tue, 16 Aug 2022 08:47:29 GMT</pubDate>
      
      <description>&lt;p&gt;朴素模式匹配算法的代码实现和KMP以及其中next数组的求法&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>朴素模式匹配算法的代码实现和KMP以及其中next数组的求法</p><span id="more"></span><h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>字符串模式匹配：在主串中找到域模式串相同的子串，并返回其所在位置</p><p>子串：主串的一部分</p><p>模式串：不一定能在主串中找到</p><p>(暴力破解（穷举）)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;                <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主串长度为n</p><p>模式串长度为m</p><p>最好时间复杂度&#x3D;O(n)</p><p>最坏时间复杂度&#x3D;O((n-m+1)m)&#x3D;O(nm)</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>基于朴素模式算法优化而来</p><p><img src="/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/image-20220604181601977.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (S[i]!=T[j])</span><br><span class="line">    j=next[j];</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据模式串T，求出next数组——&gt;利用next数据进行匹配（主指针不回溯）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1.</span>j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j ])&#123;</span><br><span class="line">            i++;j++;            <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];          <span class="comment">//主串指针i不回溯，模式串向右移动，KMP算法核心</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏时间复杂度：O(m+n)     求next数组的时间复杂度O(m)模式匹配时间复杂度O(n)</p><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a><strong>求next数组</strong></h2><p>任何模式串都一样</p><p>第一个字符不匹配时，next[1]&#x3D;0</p><p>第二个字符不匹配时，next[2]&#x3D;1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString S,SString T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">2</span> &amp;&amp; T.ch[i<span class="number">-1</span>]!=T.ch[j<span class="number">-2</span>])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[i<span class="number">-1</span>]=T.ch[j<span class="number">-1</span>])&#123;</span><br><span class="line">            length++;</span><br><span class="line">            i--,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E4%B8%B2/">串</category>
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2022/08/16/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%92%8CKPM%E7%AE%97%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>串的存储结构</title>
      <link>http://example.com/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <guid>http://example.com/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Mon, 15 Aug 2022 08:42:32 GMT</pubDate>
      
      <description>&lt;p&gt;串的顺序存储、链式存储的代码实现和基本操作的代码实现&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>串的顺序存储、链式存储的代码实现和基本操作的代码实现</p><span id="more"></span><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255     <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//每个分类存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;<span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;          <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;<span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点：随机存取</p><p>缺点：插入删除操作不方便</p><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604165848221.png"></p><p>方案一：需要额外一片空间</p><p>方案二：length只占1B即8bit所以数组不能超过255</p><p>方案三：每次求表长都需要遍历整个字符串</p><h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;                      <span class="comment">//每个结点存一个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;             <span class="comment">//存储密度低，每个字节1B，每个指针4B</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//改良</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];                   <span class="comment">//每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *String;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604171058073.png"><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604171107252.png"></p><h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172524171.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;len+pos;i++)</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">    Sub.length=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="比较两个串的大小"><a href="#比较两个串的大小" class="headerlink" title="比较两个串的大小"></a>比较两个串的大小</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/Users\18251\AppData\Roaming\Typora\typora-user-images\image-20220604172617169.png" style="zoom:67%;"><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172621936.png" style="zoom:67%;"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172716580.png"></p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220604172735794.png" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,n=S.length,m=T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E4%B8%B2/">串</category>
      
      
      <comments>http://example.com/2022/08/15/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>串的基本操作</title>
      <link>http://example.com/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Mon, 15 Aug 2022 08:39:03 GMT</pubDate>
      
      <description>&lt;p&gt;串的定义增删改查和字符集拓展内容的学习&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>串的定义增删改查和字符集拓展内容的学习</p><span id="more"></span><h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即字符串（string）由零个或者多个字符组成的有限序列，一般记为：<br>$$<br>S &#x3D;’a_1a_2….a_n’<br>$$<br>S：串名   n：串的长度   n&#x3D;0时成为空串</p><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162622856.png"></p><p>子串：串中任意个<strong>连续</strong>的字符组成的子序列</p><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163002890.png"></p><p>主串：包含子串的串</p><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162948821.png"></p><p>字符在主串中的位置：字符在串中的序号  （ps：空格也是一种字符）</p><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162939273.png"></p><p>子串在主串中的位置：子串的第一个字符在主串中的位置</p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604162903691.png" style="zoom:67%;"><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163018603.png" style="zoom:67%;"><p>串是一种特殊的线性表，数据元素之间呈现线性关系</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163702551.png"></p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604163803577.png" style="zoom:80%;"><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>y&#x3D;f(x)</p><p>字符集：函数定义域</p><p>编码：函数映射规则f</p><p>y：对应的二进制数</p><p>英文字符——ASCII字符集  （2^8只有256种状态）</p><p>中英文——Unicode字符集</p><p>考研中默认每个字符占1B</p><h4 id="拓展——乱码问题"><a href="#拓展——乱码问题" class="headerlink" title="拓展——乱码问题"></a>拓展——乱码问题</h4><p><img src="/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220604164822168.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="http://example.com/tags/%E4%B8%B2/">串</category>
      
      
      <comments>http://example.com/2022/08/15/%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sqlmap使用</title>
      <link>http://example.com/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/</link>
      <guid>http://example.com/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Mon, 15 Aug 2022 04:51:45 GMT</pubDate>
      
      <description>&lt;p&gt;sqlmap的get使用方法和post使用方法以及其他技巧(更新ing~)&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>sqlmap的get使用方法和post使用方法以及其他技巧(更新ing~)</p><span id="more"></span><h2 id="get使用方法"><a href="#get使用方法" class="headerlink" title="get使用方法"></a>get使用方法</h2><p>(1)查看是否有注入点：sqlmap -u 网址<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143754072.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143808583.png"><br>证明有注入点<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815143944207.png"><br>得到服务器操作系统为linux centOS，后端语言为php，数据库为mysql</p><p>(2)获取数据库<br>        ((1))获取全部数据库<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144244725.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144303120.png"><br>        ((2))获取当前数据库<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144412391.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144432759.png" alt="image-20220815144432759"></p><p>(3)获取当前数据库里所有表<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144547931.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815144611455.png" alt="image-20220815144611455"></p><p>(4)获取表的字段<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145336829.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145356494.png"></p><p>(5)获取字段内容<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145525659.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815145534950.png"><br>如果字段内容多的话可以再加上如 –start 1 –stop 100 ——获取1-100条数据<br>–dump 可以换成 –dump-all 导出全部内容</p><h2 id="post使用方法"><a href="#post使用方法" class="headerlink" title="post使用方法"></a>post使用方法</h2><p>通过burp抓包请求<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150536388.png"><br>用txt形式保存<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150558636.png"><br>检验注入点<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150625346.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150643242.png" alt="image-20220815150643242"><br>获取库名<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150734338.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815150746967.png"><br>其余步骤与get一样</p><h2 id="指定位置的注入"><a href="#指定位置的注入" class="headerlink" title="指定位置的注入"></a>指定位置的注入</h2><p>在想注入的地方加*<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151258357.png"><br>运行sqlmap后就会探测到*号<br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151341838.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151409577.png" alt="image-20220815151409577"></p><h2 id="盲注使用不接收http-body"><a href="#盲注使用不接收http-body" class="headerlink" title="盲注使用不接收http body"></a>盲注使用不接收http body</h2><p><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151536755.png"><br><img src="/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/image-20220815151554688.png" alt="image-20220815151554688"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/">网络攻防</category>
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      <category domain="http://example.com/tags/%E5%B7%A5%E5%85%B7/">工具</category>
      
      
      <comments>http://example.com/2022/08/15/sqlmap%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>web攻防</title>
      <link>http://example.com/2022/08/15/web%E6%94%BB%E9%98%B2/</link>
      <guid>http://example.com/2022/08/15/web%E6%94%BB%E9%98%B2/</guid>
      <pubDate>Mon, 15 Aug 2022 02:12:39 GMT</pubDate>
      
      <description>&lt;p&gt;每天几道题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>每天几道题</p><span id="more"></span><h2 id="第一题——baby-web"><a href="#第一题——baby-web" class="headerlink" title="第一题——baby_web"></a>第一题——baby_web</h2><p>掌握web相应包头部常见参数</p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101339517.png" alt="题目"></p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101408887.png" alt="打开后的图片"></p><p>根据题目描述考虑index.php页面，但是打开网页后直接跳转到了1.php，抓包得到</p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101555331.png"></p><p>扔到reperter模块，修改1.php为index.php</p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101647686.png"></p><p>看到旗帜被隐藏，看hex得到</p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815101726805.png"></p><p>或者通过开发者工具，在网络中可以看到index被重定向了<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815120359827.png"></p><h2 id="第二题——ics-06"><a href="#第二题——ics-06" class="headerlink" title="第二题——ics-06"></a>第二题——ics-06</h2><p>id爆破</p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103134706.png" alt="题目"></p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103201798.png" alt="靶场"></p><p>点击很多个地方发现只有报表中心能点，里面内容为</p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103310739.png"></p><p>选了很多个日期发现没反应网页，后来发现改id是有反应的<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103352596.png"><br>明白了，爆破，先抓包再送去炸死这道阴间题<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103500026.png"></p><p>然后我就一百个数一百个数进行爆破，在2300-2400的时候报文长度不一样了<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103556967.png"><br>看结果获得旗帜<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815103629272.png"></p><h2 id="第三题——ingnt"><a href="#第三题——ingnt" class="headerlink" title="第三题——ingnt"></a>第三题——ingnt</h2><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115158896.png" alt="题目"></p><p><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115217584.png" alt="靶场"></p><p>没有什么可操作的地方除了地址框，猜测是sql注入<br>方法1：直接采用万能钥匙<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115337825.png"></p><p>方法二：sqlmap一把梭<br>先查数据库名<img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115419759.png" alt="image-20220815115419759"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115447014.png"><br>查表名<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115506861.png"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115521175.png"><br>输出表中所有字段<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115600014.png"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115612711.png"><br>输出pw字段内容<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115639962.png"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115652969.png"><br>得到flag</p><p>直接一把梭<br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115726708.png"><br><img src="/2022/08/15/web%E6%94%BB%E9%98%B2/image-20220815115746924.png"></p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/">网络攻防</category>
      
      <category domain="http://example.com/tags/%E5%AE%9E%E4%BE%8B/">实例</category>
      
      
      <comments>http://example.com/2022/08/15/web%E6%94%BB%E9%98%B2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
